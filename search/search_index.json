{
    "docs": [
        {
            "location": "/", 
            "text": "CIDER is the \nC\nlojure(Script) \nI\nnteractive \nD\nevelopment \nE\nnvironment\nthat \nR\nocks!\n\n\nCIDER extends Emacs with support for interactive programming in Clojure. The\nfeatures are centered around \ncider-mode\n, an Emacs minor-mode that complements\n\nclojure-mode\n. While \nclojure-mode\n supports editing Clojure source files,\n\ncider-mode\n adds support for interacting with a running Clojure process for\ncompilation, debugging, definition and documentation lookup, running tests and\nso on.\n\n\nCIDER is the successor to the now deprecated combination of using \nSLIME\n +\n\nswank-clojure\n for Clojure development.\n\n\nPlease consider\n\nsupporting financially its ongoing development\n.\n\n\nOverview\n\n\nCIDER aims to provide an interactive development experience similar to the one\nyou'd get when programming in Emacs Lisp, Common Lisp (with \nSLIME\n or \nSly\n),\nScheme (with \nGeiser\n) and Smalltalk.\n\n\nProgrammers are expected to program in a very dynamic and incremental manner,\nconstantly re-evaluating existing Clojure definitions and adding new ones to\ntheir running applications. You never stop/start a Clojure application while\nusing CIDER - you're constantly interacting with it and changing it.\n\n\nYou can find more details about the typical CIDER workflow in the\n\nInteractive Programming\n section. While we're a bit\nshort on video tutorials, you can check out this\n\ntutorial about SLIME\n to get a\nfeel about what do we mean by an \"Interactive Development Environment\".  There\nare plenty of differences between CIDER and SLIME, but the core ideas are pretty\nmuch the same (and SLIME served as the principle inspiration for CIDER).\n\n\nCIDER's built on top of \nnREPL\n, the Clojure networked REPL server.\n\n\nCIDER's basic architecture looks something like this:\n\n\n\n  \n\n\n\n\n\nClojure code gets executed by an nREPL server. CIDER sends requests to the\nserver and processes its responses. The server's functionality is augmented by\nadditional nREPL middleware, designed specifically to address the needs of an\ninteractive development environment like CIDER. Much of the middleware we\ndeveloped for CIDER is editor-agnostic and is being used by other Clojure\ndevelopment environments as well (e.g. \nvim-fireplace\n \n \nCCW\n).\n\n\nCIDER packs plenty of features. Here are some of them (in no particular order):\n\n\n\n\nPowerful REPL\n\n\nInteractive code evaluation\n\n\nCompilation notes (error and warning highlighting)\n\n\nHuman-friendly stacktraces\n\n\nSmart code completion\n\n\nDefinition lookup\n\n\nDocumentation lookup\n\n\nResource lookup\n\n\nApropos\n\n\nDebugger\n\n\nValue inspector\n\n\nFunction tracing\n\n\nInteractive macroexpansion\n\n\nEnhanced Clojure font-locking and indentation\n\n\nGrimoire\n integration\n\n\nclojure.test\n integration\n\n\nSmart code reloading\n\n\nPretty-printing of results\n\n\nClasspath browser\n\n\nNamespace browser\n\n\nREPL history browser\n\n\nnREPL session management\n\n\nScratchpad\n\n\nMinibuffer code evaluation\n\n\nIntegration with \ncompany-mode\n and \nauto-complete-mode\n\n\nSupport for working with multiple simultaneous nREPL connections", 
            "title": "Home"
        }, 
        {
            "location": "/#overview", 
            "text": "CIDER aims to provide an interactive development experience similar to the one\nyou'd get when programming in Emacs Lisp, Common Lisp (with  SLIME  or  Sly ),\nScheme (with  Geiser ) and Smalltalk.  Programmers are expected to program in a very dynamic and incremental manner,\nconstantly re-evaluating existing Clojure definitions and adding new ones to\ntheir running applications. You never stop/start a Clojure application while\nusing CIDER - you're constantly interacting with it and changing it.  You can find more details about the typical CIDER workflow in the Interactive Programming  section. While we're a bit\nshort on video tutorials, you can check out this tutorial about SLIME  to get a\nfeel about what do we mean by an \"Interactive Development Environment\".  There\nare plenty of differences between CIDER and SLIME, but the core ideas are pretty\nmuch the same (and SLIME served as the principle inspiration for CIDER).  CIDER's built on top of  nREPL , the Clojure networked REPL server.  CIDER's basic architecture looks something like this:  \n     Clojure code gets executed by an nREPL server. CIDER sends requests to the\nserver and processes its responses. The server's functionality is augmented by\nadditional nREPL middleware, designed specifically to address the needs of an\ninteractive development environment like CIDER. Much of the middleware we\ndeveloped for CIDER is editor-agnostic and is being used by other Clojure\ndevelopment environments as well (e.g.  vim-fireplace     CCW ).  CIDER packs plenty of features. Here are some of them (in no particular order):   Powerful REPL  Interactive code evaluation  Compilation notes (error and warning highlighting)  Human-friendly stacktraces  Smart code completion  Definition lookup  Documentation lookup  Resource lookup  Apropos  Debugger  Value inspector  Function tracing  Interactive macroexpansion  Enhanced Clojure font-locking and indentation  Grimoire  integration  clojure.test  integration  Smart code reloading  Pretty-printing of results  Classpath browser  Namespace browser  REPL history browser  nREPL session management  Scratchpad  Minibuffer code evaluation  Integration with  company-mode  and  auto-complete-mode  Support for working with multiple simultaneous nREPL connections", 
            "title": "Overview"
        }, 
        {
            "location": "/installation/", 
            "text": "The canonical way to install CIDER is via \npackage.el\n (Emacs's built-in package\nmanager), but it can be installed manually or via alternative package managers such\nas \nel-get\n.\n\n\nPrerequisites\n\n\nYou'll need to have Emacs installed (preferably the latest stable\nrelease). If you're new to Emacs you might want to go through\n\nthe guided tour of Emacs\n\nand the built-in tutorial (just press \nC-h t\n).\n\n\nCIDER officially supports Emacs 24.4+, Java 7+ and Clojure(Script) 1.7+.\nCIDER 0.10 was the final release which supported Java 6 and Clojure 1.5 and 1.6.\n\n\nYou'll also need a recent version of your favorite build tool (Leiningen, Boot\nor Gradle) to be able to start CIDER via \ncider-jack-in\n. Generally it's a good\nidea to use their latest stable versions.\n\n\nCIDER does not support ClojureCLR.\n\n\nInstallation via package.el\n\n\nCIDER is available on the two major \npackage.el\n community\nmaintained repos -\n\nMELPA Stable\n\nand \nMELPA\n.\n\n\nYou can install CIDER with the following command:\n\n\nM-x package-install [RET] cider [RET]\n\n\nor by adding this bit of Emacs Lisp code to your Emacs initialization file\n(\n.emacs\n or \ninit.el\n):\n\n\n(unless (package-installed-p 'cider)\n  (package-install 'cider))\n\n\n\n\nIf the installation doesn't work try refreshing the package list:\n\n\nM-x package-refresh-contents [RET]\n\n\nKeep in mind that MELPA packages are built automatically from\nthe \nmaster\n branch, meaning bugs might creep in there from time to\ntime. Never-the-less, installing from MELPA is a reasonable way of\nobtaining CIDER, as the \nmaster\n branch is normally quite stable\nand serious regressions there are usually fixed pretty quickly.\n\n\nGenerally, users of the non-adventurous kind are advised to stick\nwith the stable releases, available from MELPA Stable.\nIn Emacs 24.4+, you can pin CIDER to always use MELPA\nStable by adding this to your Emacs initialization:\n\n\n(add-to-list 'package-pinned-packages '(cider . \nmelpa-stable\n) t)\n\n\n\n\nCIDER has dependencies (e.g. \nqueue\n \n \nseq\n) that are only available in the\n  \nGNU ELPA repository\n. It's the only package repository\n  enabled by default in Emacs and you should not disable it!\n\n\nInstallation via use-package\n\n\nuse-package\n can be used to install CIDER via the \npackage.el\n's repositories\n\nMELPA Stable\n and \nMELPA\n.\n\n\nIf you wanted to install the version of CIDER which is what is to be found in\nthe \nmaster\n branch, declare the following in your Emacs initialization file\n(\n.emacs\n or \ninit.el\n):\n\n\n(use-package cider\n  :ensure t)\n\n\n\n\nHowever, if you wanted to be a bit more conservative and only use the stable\nreleases of CIDER, you'd declare the following:\n\n\n(use-package cider\n  :ensure t\n  :pin melpa-stable)\n\n\n\n\nAfter placing one of the above s-expressions, evaluate it, for it to take effect\nby entering: \nC-x C-e\n.\n\n\nFor further configuration options with \nuse-package\n, consult the\nofficial \nuse-package repository\n.\n\n\nInstallation via el-get\n\n\nCIDER is also available for installation from\nthe \nel-get\n package manager.\n\n\nProvided you've already installed \nel-get\n you can install CIDER with the\nfollowing command:\n\n\nM-x el-get-install [RET] cider [RET]\n\n\nManual installation\n\n\nAlternatively you can simply load CIDER in your Emacs straight from its source\nrepo. Assuming you've already obtained the code you should add something like\nthis to your Emacs configuration:\n\n\n;; load CIDER from its source code\n(add-to-list 'load-path \n~/projects/cider\n)\n(require 'cider)\n\n\n\n\nJust keep in mind that you'll have to manually install all the packages CIDER\ndepends on in advance.\n\n\nCIDER's nREPL middleware\n\n\nMuch of CIDER's functionality depends on the presence of CIDER's\nown \nnREPL middleware\n. Starting\nwith version 0.11, When \ncider-jack-in\n (\nC-c M-j\n) is used, CIDER\ntakes care of injecting it and its other dependencies.\n\n\nprofiles.clj\n or \nprofile.boot\n don't need to be modified anymore for the above use case!\n\n\nIf you don't want \ncider-jack-in\n to inject dependencies automatically, set\n\ncider-inject-dependencies-at-jack-in\n to \nnil\n. Note that you'll have to setup\nthe dependencies yourself (see the section below), just as in CIDER 0.10 and older.\n\n\nCIDER can also inject a Clojure dependency into your project, which is useful,\nfor example, if your project defaults to an older version of Clojure than that\nsupported by the CIDER middleware. Set \ncider-jack-in-auto-inject-clojure\n\nappropriately to enable this.\n\n\nIf a standalone REPL is preferred, you need to invoke \ncider-connect\n (instead\nof \ncider-jack-in\n) and you'll need to manually add the dependencies to your\nClojure project (explained in the following section).\n\n\nSetting up a standalone REPL\n\n\nUsing Leiningen\n\n\nUse the convenient plugin for defaults, either in your project's\n\nproject.clj\n file or in the :repl profile in \n~/.lein/profiles.clj\n.\n\n\n:plugins [[cider/cider-nrepl \nx.y.z\n]]\n\n\n\n\nA minimal \nprofiles.clj\n for CIDER would be:\n\n\n{:repl {:plugins [[cider/cider-nrepl \n0.16.0\n]]}}\n\n\n\n\nBe careful not to place this in the \n:user\n profile, as this way CIDER's\nmiddleware will always get loaded, causing \nlein\n to start slower.  You really\nneed it just for \nlein repl\n and this is what the \n:repl\n profile is for.\n\n\nUsing Boot\n\n\nBoot users can configure the tool to include the middleware automatically in\nall of their projects using a \n~/.boot/profile.boot\n file like so:\n\n\n(require 'boot.repl)\n\n(swap! boot.repl/*default-dependencies*\n       concat '[[cider/cider-nrepl \n0.16.0\n]])\n\n(swap! boot.repl/*default-middleware*\n       conj 'cider.nrepl/cider-middleware)\n\n\n\n\nFor more information visit \nboot-clj wiki\n.\n\n\nUsing embedded nREPL server\n\n\nIf you're embedding nREPL in your application you'll have to start the\nserver with CIDER's own nREPL handler.\n\n\n(ns my-app\n  (:require [clojure.tools.nrepl.server :as nrepl-server]\n            [cider.nrepl :refer (cider-nrepl-handler)]))\n\n(defn -main\n  []\n  (nrepl-server/start-server :port 7888 :handler cider-nrepl-handler))\n\n\n\n\nIt goes without saying that your project should depend on \ncider-nrepl\n.\n\n\n\n\nx.y.z\n should match the version of CIDER you're currently using (say \n0.16.0\n).\nFor snapshot releases of CIDER you should use the snapshot of the plugin as well\n(say \n0.16.0-SNAPSHOT\n).", 
            "title": "Installation"
        }, 
        {
            "location": "/installation/#prerequisites", 
            "text": "You'll need to have Emacs installed (preferably the latest stable\nrelease). If you're new to Emacs you might want to go through the guided tour of Emacs \nand the built-in tutorial (just press  C-h t ).  CIDER officially supports Emacs 24.4+, Java 7+ and Clojure(Script) 1.7+.\nCIDER 0.10 was the final release which supported Java 6 and Clojure 1.5 and 1.6.  You'll also need a recent version of your favorite build tool (Leiningen, Boot\nor Gradle) to be able to start CIDER via  cider-jack-in . Generally it's a good\nidea to use their latest stable versions.  CIDER does not support ClojureCLR.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/installation/#installation-via-packageel", 
            "text": "CIDER is available on the two major  package.el  community\nmaintained repos - MELPA Stable \nand  MELPA .  You can install CIDER with the following command:  M-x package-install [RET] cider [RET]  or by adding this bit of Emacs Lisp code to your Emacs initialization file\n( .emacs  or  init.el ):  (unless (package-installed-p 'cider)\n  (package-install 'cider))  If the installation doesn't work try refreshing the package list:  M-x package-refresh-contents [RET]  Keep in mind that MELPA packages are built automatically from\nthe  master  branch, meaning bugs might creep in there from time to\ntime. Never-the-less, installing from MELPA is a reasonable way of\nobtaining CIDER, as the  master  branch is normally quite stable\nand serious regressions there are usually fixed pretty quickly.  Generally, users of the non-adventurous kind are advised to stick\nwith the stable releases, available from MELPA Stable.\nIn Emacs 24.4+, you can pin CIDER to always use MELPA\nStable by adding this to your Emacs initialization:  (add-to-list 'package-pinned-packages '(cider .  melpa-stable ) t)  CIDER has dependencies (e.g.  queue     seq ) that are only available in the\n   GNU ELPA repository . It's the only package repository\n  enabled by default in Emacs and you should not disable it!", 
            "title": "Installation via package.el"
        }, 
        {
            "location": "/installation/#installation-via-use-package", 
            "text": "use-package  can be used to install CIDER via the  package.el 's repositories MELPA Stable  and  MELPA .  If you wanted to install the version of CIDER which is what is to be found in\nthe  master  branch, declare the following in your Emacs initialization file\n( .emacs  or  init.el ):  (use-package cider\n  :ensure t)  However, if you wanted to be a bit more conservative and only use the stable\nreleases of CIDER, you'd declare the following:  (use-package cider\n  :ensure t\n  :pin melpa-stable)  After placing one of the above s-expressions, evaluate it, for it to take effect\nby entering:  C-x C-e .  For further configuration options with  use-package , consult the\nofficial  use-package repository .", 
            "title": "Installation via use-package"
        }, 
        {
            "location": "/installation/#installation-via-el-get", 
            "text": "CIDER is also available for installation from\nthe  el-get  package manager.  Provided you've already installed  el-get  you can install CIDER with the\nfollowing command:  M-x el-get-install [RET] cider [RET]", 
            "title": "Installation via el-get"
        }, 
        {
            "location": "/installation/#manual-installation", 
            "text": "Alternatively you can simply load CIDER in your Emacs straight from its source\nrepo. Assuming you've already obtained the code you should add something like\nthis to your Emacs configuration:  ;; load CIDER from its source code\n(add-to-list 'load-path  ~/projects/cider )\n(require 'cider)  Just keep in mind that you'll have to manually install all the packages CIDER\ndepends on in advance.", 
            "title": "Manual installation"
        }, 
        {
            "location": "/installation/#ciders-nrepl-middleware", 
            "text": "Much of CIDER's functionality depends on the presence of CIDER's\nown  nREPL middleware . Starting\nwith version 0.11, When  cider-jack-in  ( C-c M-j ) is used, CIDER\ntakes care of injecting it and its other dependencies.  profiles.clj  or  profile.boot  don't need to be modified anymore for the above use case!  If you don't want  cider-jack-in  to inject dependencies automatically, set cider-inject-dependencies-at-jack-in  to  nil . Note that you'll have to setup\nthe dependencies yourself (see the section below), just as in CIDER 0.10 and older.  CIDER can also inject a Clojure dependency into your project, which is useful,\nfor example, if your project defaults to an older version of Clojure than that\nsupported by the CIDER middleware. Set  cider-jack-in-auto-inject-clojure \nappropriately to enable this.  If a standalone REPL is preferred, you need to invoke  cider-connect  (instead\nof  cider-jack-in ) and you'll need to manually add the dependencies to your\nClojure project (explained in the following section).", 
            "title": "CIDER's nREPL middleware"
        }, 
        {
            "location": "/installation/#setting-up-a-standalone-repl", 
            "text": "", 
            "title": "Setting up a standalone REPL"
        }, 
        {
            "location": "/installation/#using-leiningen", 
            "text": "Use the convenient plugin for defaults, either in your project's project.clj  file or in the :repl profile in  ~/.lein/profiles.clj .  :plugins [[cider/cider-nrepl  x.y.z ]]  A minimal  profiles.clj  for CIDER would be:  {:repl {:plugins [[cider/cider-nrepl  0.16.0 ]]}}  Be careful not to place this in the  :user  profile, as this way CIDER's\nmiddleware will always get loaded, causing  lein  to start slower.  You really\nneed it just for  lein repl  and this is what the  :repl  profile is for.", 
            "title": "Using Leiningen"
        }, 
        {
            "location": "/installation/#using-boot", 
            "text": "Boot users can configure the tool to include the middleware automatically in\nall of their projects using a  ~/.boot/profile.boot  file like so:  (require 'boot.repl)\n\n(swap! boot.repl/*default-dependencies*\n       concat '[[cider/cider-nrepl  0.16.0 ]])\n\n(swap! boot.repl/*default-middleware*\n       conj 'cider.nrepl/cider-middleware)  For more information visit  boot-clj wiki .", 
            "title": "Using Boot"
        }, 
        {
            "location": "/installation/#using-embedded-nrepl-server", 
            "text": "If you're embedding nREPL in your application you'll have to start the\nserver with CIDER's own nREPL handler.  (ns my-app\n  (:require [clojure.tools.nrepl.server :as nrepl-server]\n            [cider.nrepl :refer (cider-nrepl-handler)]))\n\n(defn -main\n  []\n  (nrepl-server/start-server :port 7888 :handler cider-nrepl-handler))  It goes without saying that your project should depend on  cider-nrepl .   x.y.z  should match the version of CIDER you're currently using (say  0.16.0 ).\nFor snapshot releases of CIDER you should use the snapshot of the plugin as well\n(say  0.16.0-SNAPSHOT ).", 
            "title": "Using embedded nREPL server"
        }, 
        {
            "location": "/up_and_running/", 
            "text": "The only requirement to use CIDER is to have an nREPL server to which it may\nconnect. Many Clojurians favour the use of tools like Leiningen, Boot or Gradle\nto start an nREPL server, but the use of one of them is not a prerequisite to\nuse CIDER (however, it \nis\n required if you want to use the \ncider-jack-in\n\ncommand).\n\n\nSetting up a Leiningen or Boot project (optional)\n\n\nLeiningen\n is the de-facto standard build/project\nmanagement tool for Clojure. \nBoot\n is a newer build tool\noffering abstractions and libraries to construct more complex build\nscenarios. Both have a similar scope to the Maven build tool favoured by Java\ndevelopers (and they actually reuse many things from the Maven ecosystem).\n\n\nCIDER features a command called \ncider-jack-in\n that will start an nREPL server\nfor a particular Leiningen or Boot project and connect to it automatically.\nThis functionality depends on Leiningen 2.5.2+ or Boot\n2.7.0+. Older versions are not supported. For Leiningen, follow the installation\ninstructions on its web site to get it up and running and afterwards create a\nproject like this:\n\n\n$ lein new demo\n\n\n\n\nThe two main ways to obtain an nREPL connection are discussed in the following sections of the manual.\n\n\nLaunch an nREPL server and client from Emacs\n\n\nSimply open in Emacs a file belonging to your \nlein\n or \nboot\n project (like\n\nfoo.clj\n) and type \nM-x\n \ncider-jack-in\n \nRET\n. This will\nstart an nREPL server with all the project dependencies loaded in and CIDER will\nautomatically connect to it.\n\n\nAlternatively you can use \nC-u M-x\n \ncider-jack-in\n \nRET\n to\nspecify the name of a \nlein\n or \nboot\n project, without having to visit any file\nin it. This option is also useful if your project contains both \nproject.clj\n\nand \nbuild.boot\n and you want to launch a repl for one or the other.\n\n\nIn Clojure(Script) buffers the command \ncider-jack-in\n is bound to \nC-c M-j\n.\n\n\nFor further customizing the command line used for \ncider-jack-in\n, you can\nchange the following (all string options):\n\n\n\n\ncider-lein-global-options\n, \ncider-boot-global-options\n, \ncider-gradle-global-options\n: these are passed to the command directly, in first position (e.g. \n-o\n to \nlein\n enables offline mode).\n\n\ncider-lein-parameters\n, \ncider-boot-parameters\n, \ncider-gradle-parameters\n: these are usually tasks names and their parameters (e.g.: \ndev\n for launching boot's dev task instead of the standard \nrepl -s  wait\n).\n\n\n\n\nConnect to a running nREPL server\n\n\nYou can go to your project's directory in a terminal and type there:\n\n\n$ lein repl\n\n\n\n\nOr:\n\n\n$ boot repl -s wait (or whatever task launches a repl)\n\n\n\n\nAlternatively you can start nREPL either manually or by the facilities provided by your\nproject's build tool (Maven, etc).\n\n\nAfter you get your nREPL server running go back to Emacs.  Typing there\n\nM-x\n \ncider-connect\n \nRET\n will allow you to connect to the\nrunning nREPL server.\n\n\nIn Clojure(Script) buffers the command \ncider-connect\n is bound to \nC-c M-c\n.\n\n\nYou can configure known endpoints used by the \ncider-connect\n command offered\nvia a completing read. This is useful if you have a list of common host/ports\nyou want to establish remote nREPL connections to. Using an optional label is\nhelpful for identifying each host.\n\n\n(setq cider-known-endpoints '((\nhost-a\n \n10.10.10.1\n \n7888\n) (\nhost-b\n \n7888\n)))\n\n\n\n\nClojureScript usage\n\n\nClojureScript support relies on the \npiggieback\n nREPL middleware being\npresent in your REPL session.\n\n\nAdd the following dependencies to your project (\nproject.clj\n in Leiningen based project\nor \nbuilt.boot\n in Boot project):\n\n\n[com.cemerick/piggieback \n0.2.1\n]\n[org.clojure/clojure \n1.7.0\n]\n\n\n\n\nas well as \npiggieback\n nREPL middleware:\n\n\nin \nproject.clj\n:\n\n\n:repl-options {:nrepl-middleware [cemerick.piggieback/wrap-cljs-repl]}\n\n\n\n\nor in \nbuilt.boot\n:\n\n\n(task-options!\n  repl {:middleware '[cemerick.piggieback/wrap-cljs-repl]})\n\n\n\n\nIssue \nM-x\n \ncustomize-variable\n \nRET\n and either\n\ncider-cljs-lein-repl\n, \ncider-cljs-boot-repl\n or \ncider-cljs-gradle-repl\n if\nyou'd like to change the REPL used (the default is \nrhino\n where possible).\n\n\nOpen a file in your project and issue \nM-x\n\n\ncider-jack-in-clojurescript\n \nRET\n. This will start up the nREPL\nserver, and then create two REPL buffers for you, one in Clojure and one in\nClojureScript. All usual CIDER commands will be automatically directed to the\nappropriate REPL, depending on whether you're visiting a \n.clj\n or a \n.cljs\n\nfile.\n\n\nBrowser-connected ClojureScript REPL\n\n\nUsing Weasel, you can also have a browser-connected REPL.\n\n\n\n\n\n\nAdd \n[weasel \"0.7.0\"]\n to your project's \n:dependencies\n.\n\n\n\n\n\n\nIssue \nM-x\n \ncustomize-variable\n \nRET\n plus either\n   \ncider-cljs-lein-repl\n, \ncider-cljs-boot-repl\n or \ncider-cljs-gradle-repl\n\n   and choose the \nWeasel\n option.\n\n\n\n\n\n\nAdd this to your ClojureScript code:\n\n\n\n\n\n\n(ns my.cljs.core\n  (:require [weasel.repl :as repl]))\n(repl/connect \nws://localhost:9001\n)\n\n\n\n\n\n\nOpen a file in your project and issue \nM-x\n \ncider-jack-in-clojurescript\n.\n\n\n\n\nProvided that a Piggieback-enabled ClojureScript environment is active in your\nREPL session, code loading and evaluation will work seamlessly regardless of the\npresence of the \ncider-nrepl\n middleware. If the middleware is present then most\nother features of CIDER will also be enabled (including code completion,\ndocumentation lookup, the namespace browser, and macroexpansion).\n\n\nBrowser-connected ClojureScript REPL in Boot project\n\n\n\n\nAdd this to your dependencies in \nbuild.boot\n:\n\n\n\n\n[adzerk/boot-cljs        \nX.Y.Z\n  :scope \ntest\n]\n[adzerk/boot-cljs-repl   \nX.Y.Z\n  :scope \ntest\n]\n[pandeiro/boot-http      \nX.Y.Z\n  :scope \ntest\n]\n[weasel                  \n0.7.0\n  :scope \ntest\n]\n[com.cemerick/piggieback \n0.2.1\n  :scope \ntest\n]\n\n\n\n\nand this at the end of \nbuild.boot\n:\n\n\n(require\n '[adzerk.boot-cljs :refer [cljs]]\n '[adzerk.boot-cljs-repl :refer [cljs-repl]]\n '[pandeiro.boot-http :refer [serve]])\n\n(deftask dev []\n  (comp (serve)\n        (watch)\n        (cljs-repl) ; order is important!!\n        (cljs)))\n\n\n\n\n\n\n\n\nIssue \nM-x\n \ncustomize-variable\n \nRET\n \ncider-boot-parameters\n\n   and insert \ndev\n.\n\n\n\n\n\n\nOpen a file in your project and issue \nM-x\n \ncider-jack-in-clojurescript\n.\n\n\n\n\n\n\nConnect to the running server with your browser. The address is printed on the terminal, but it's probably \nhttp://localhost:3000\n.\n\n\n\n\n\n\nFor more information visit \nboot-cljs-repl\n.\n\n\nUsing the Figwheel REPL (Leiningen-only)\n\n\nYou can also use \nFigwheel\n with CIDER.\n\n\n\n\n\n\nSet up Figwheel as normal, but make sure \n:cljsbuild\n and \n:figwheel\n settings are\n   in the root of your Leiningen project definition.\n\n\n\n\n\n\nAdd these to your dev \n:dependencies\n:\n\n\n\n\n\n\n[com.cemerick/piggieback \n0.2.1\n]\n[figwheel-sidecar \n0.5.0-2\n]\n\n\n\n\n\n\nAdd this to your dev \n:repl-options\n:\n\n\n\n\n:nrepl-middleware [cemerick.piggieback/wrap-cljs-repl]\n\n\n\n\n\n\nInstruct CIDER to use Figwheel in your Emacs config:\n\n\n\n\n(setq cider-cljs-lein-repl \n(do (use 'figwheel-sidecar.repl-api) (start-figwheel!) (cljs-repl))\n)\n\n\n\n\n\n\n\n\nStart the REPL with \ncider-jack-in-clojurescript\n (\nC-c M-J\n)\n\n\n\n\n\n\nOpen a browser to the Figwheel URL so that it can connect to your application.\n\n\n\n\n\n\nYou now have two nREPL connections, one for Clojure and one for ClojureScript.\nCIDER will determine which to use based on the type of file you're editing.\n\n\nYou should also check out\n\nFigwheel's wiki\n.\n\n\nWorking with \n.cljc\n files\n\n\nOrdinarily, CIDER dispatches code from \nclj\n files to Clojure REPLs and \ncljs\n\nfiles to ClojureScript REPLs. However, \ncljc\n files have two possible connection\ntargets. By default, CIDER tries to evaluate \ncljc\n files in all matching\nconnection buffers, both \nclj\n and \ncljs\n (if present).\n\n\nSimply put - if you're evaluating the code \n(+ 2 2)\n in a \ncljc\n file and you\nhave an active Clojure and and active ClojureScript REPL, then the code is going\nto be evaluated 2 times - once for each of them. This behavior might be a bit\nconfusing, but that's what we came up with, when ruminating what was the most\nlogical thing to do out-of-the-box.\n\n\nThis can be modified with \nM-x\n \ncider-toggle-connection-buffer\n\n\nRET\n. Toggling this once will choose one of the connections as the\nprimary, and successive calls to \nM-x\n \ncider-toggle-connection-buffer\n\n\nRET\n will alternate which connection to use. To restore evaluation to\nboth connections, invoke \ncider-toggle-connection-buffer\n with a prefix argument\n(\nC-u M-x\n \ncider-toggle-connection-buffer\n \nRET\n).\n\n\nIf there is only a Clojure connection, no toggling will happen and a message\nwill inform you that there are no other connections to switch to.", 
            "title": "Up and Running"
        }, 
        {
            "location": "/up_and_running/#setting-up-a-leiningen-or-boot-project-optional", 
            "text": "Leiningen  is the de-facto standard build/project\nmanagement tool for Clojure.  Boot  is a newer build tool\noffering abstractions and libraries to construct more complex build\nscenarios. Both have a similar scope to the Maven build tool favoured by Java\ndevelopers (and they actually reuse many things from the Maven ecosystem).  CIDER features a command called  cider-jack-in  that will start an nREPL server\nfor a particular Leiningen or Boot project and connect to it automatically.\nThis functionality depends on Leiningen 2.5.2+ or Boot\n2.7.0+. Older versions are not supported. For Leiningen, follow the installation\ninstructions on its web site to get it up and running and afterwards create a\nproject like this:  $ lein new demo  The two main ways to obtain an nREPL connection are discussed in the following sections of the manual.", 
            "title": "Setting up a Leiningen or Boot project (optional)"
        }, 
        {
            "location": "/up_and_running/#launch-an-nrepl-server-and-client-from-emacs", 
            "text": "Simply open in Emacs a file belonging to your  lein  or  boot  project (like foo.clj ) and type  M-x   cider-jack-in   RET . This will\nstart an nREPL server with all the project dependencies loaded in and CIDER will\nautomatically connect to it.  Alternatively you can use  C-u M-x   cider-jack-in   RET  to\nspecify the name of a  lein  or  boot  project, without having to visit any file\nin it. This option is also useful if your project contains both  project.clj \nand  build.boot  and you want to launch a repl for one or the other.  In Clojure(Script) buffers the command  cider-jack-in  is bound to  C-c M-j .  For further customizing the command line used for  cider-jack-in , you can\nchange the following (all string options):   cider-lein-global-options ,  cider-boot-global-options ,  cider-gradle-global-options : these are passed to the command directly, in first position (e.g.  -o  to  lein  enables offline mode).  cider-lein-parameters ,  cider-boot-parameters ,  cider-gradle-parameters : these are usually tasks names and their parameters (e.g.:  dev  for launching boot's dev task instead of the standard  repl -s  wait ).", 
            "title": "Launch an nREPL server and client from Emacs"
        }, 
        {
            "location": "/up_and_running/#connect-to-a-running-nrepl-server", 
            "text": "You can go to your project's directory in a terminal and type there:  $ lein repl  Or:  $ boot repl -s wait (or whatever task launches a repl)  Alternatively you can start nREPL either manually or by the facilities provided by your\nproject's build tool (Maven, etc).  After you get your nREPL server running go back to Emacs.  Typing there M-x   cider-connect   RET  will allow you to connect to the\nrunning nREPL server.  In Clojure(Script) buffers the command  cider-connect  is bound to  C-c M-c .  You can configure known endpoints used by the  cider-connect  command offered\nvia a completing read. This is useful if you have a list of common host/ports\nyou want to establish remote nREPL connections to. Using an optional label is\nhelpful for identifying each host.  (setq cider-known-endpoints '(( host-a   10.10.10.1   7888 ) ( host-b   7888 )))", 
            "title": "Connect to a running nREPL server"
        }, 
        {
            "location": "/up_and_running/#clojurescript-usage", 
            "text": "ClojureScript support relies on the  piggieback  nREPL middleware being\npresent in your REPL session.  Add the following dependencies to your project ( project.clj  in Leiningen based project\nor  built.boot  in Boot project):  [com.cemerick/piggieback  0.2.1 ]\n[org.clojure/clojure  1.7.0 ]  as well as  piggieback  nREPL middleware:  in  project.clj :  :repl-options {:nrepl-middleware [cemerick.piggieback/wrap-cljs-repl]}  or in  built.boot :  (task-options!\n  repl {:middleware '[cemerick.piggieback/wrap-cljs-repl]})  Issue  M-x   customize-variable   RET  and either cider-cljs-lein-repl ,  cider-cljs-boot-repl  or  cider-cljs-gradle-repl  if\nyou'd like to change the REPL used (the default is  rhino  where possible).  Open a file in your project and issue  M-x  cider-jack-in-clojurescript   RET . This will start up the nREPL\nserver, and then create two REPL buffers for you, one in Clojure and one in\nClojureScript. All usual CIDER commands will be automatically directed to the\nappropriate REPL, depending on whether you're visiting a  .clj  or a  .cljs \nfile.", 
            "title": "ClojureScript usage"
        }, 
        {
            "location": "/up_and_running/#browser-connected-clojurescript-repl", 
            "text": "Using Weasel, you can also have a browser-connected REPL.    Add  [weasel \"0.7.0\"]  to your project's  :dependencies .    Issue  M-x   customize-variable   RET  plus either\n    cider-cljs-lein-repl ,  cider-cljs-boot-repl  or  cider-cljs-gradle-repl \n   and choose the  Weasel  option.    Add this to your ClojureScript code:    (ns my.cljs.core\n  (:require [weasel.repl :as repl]))\n(repl/connect  ws://localhost:9001 )   Open a file in your project and issue  M-x   cider-jack-in-clojurescript .   Provided that a Piggieback-enabled ClojureScript environment is active in your\nREPL session, code loading and evaluation will work seamlessly regardless of the\npresence of the  cider-nrepl  middleware. If the middleware is present then most\nother features of CIDER will also be enabled (including code completion,\ndocumentation lookup, the namespace browser, and macroexpansion).", 
            "title": "Browser-connected ClojureScript REPL"
        }, 
        {
            "location": "/up_and_running/#browser-connected-clojurescript-repl-in-boot-project", 
            "text": "Add this to your dependencies in  build.boot :   [adzerk/boot-cljs         X.Y.Z   :scope  test ]\n[adzerk/boot-cljs-repl    X.Y.Z   :scope  test ]\n[pandeiro/boot-http       X.Y.Z   :scope  test ]\n[weasel                   0.7.0   :scope  test ]\n[com.cemerick/piggieback  0.2.1   :scope  test ]  and this at the end of  build.boot :  (require\n '[adzerk.boot-cljs :refer [cljs]]\n '[adzerk.boot-cljs-repl :refer [cljs-repl]]\n '[pandeiro.boot-http :refer [serve]])\n\n(deftask dev []\n  (comp (serve)\n        (watch)\n        (cljs-repl) ; order is important!!\n        (cljs)))    Issue  M-x   customize-variable   RET   cider-boot-parameters \n   and insert  dev .    Open a file in your project and issue  M-x   cider-jack-in-clojurescript .    Connect to the running server with your browser. The address is printed on the terminal, but it's probably  http://localhost:3000 .    For more information visit  boot-cljs-repl .", 
            "title": "Browser-connected ClojureScript REPL in Boot project"
        }, 
        {
            "location": "/up_and_running/#using-the-figwheel-repl-leiningen-only", 
            "text": "You can also use  Figwheel  with CIDER.    Set up Figwheel as normal, but make sure  :cljsbuild  and  :figwheel  settings are\n   in the root of your Leiningen project definition.    Add these to your dev  :dependencies :    [com.cemerick/piggieback  0.2.1 ]\n[figwheel-sidecar  0.5.0-2 ]   Add this to your dev  :repl-options :   :nrepl-middleware [cemerick.piggieback/wrap-cljs-repl]   Instruct CIDER to use Figwheel in your Emacs config:   (setq cider-cljs-lein-repl  (do (use 'figwheel-sidecar.repl-api) (start-figwheel!) (cljs-repl)) )    Start the REPL with  cider-jack-in-clojurescript  ( C-c M-J )    Open a browser to the Figwheel URL so that it can connect to your application.    You now have two nREPL connections, one for Clojure and one for ClojureScript.\nCIDER will determine which to use based on the type of file you're editing.  You should also check out Figwheel's wiki .", 
            "title": "Using the Figwheel REPL (Leiningen-only)"
        }, 
        {
            "location": "/up_and_running/#working-with-cljc-files", 
            "text": "Ordinarily, CIDER dispatches code from  clj  files to Clojure REPLs and  cljs \nfiles to ClojureScript REPLs. However,  cljc  files have two possible connection\ntargets. By default, CIDER tries to evaluate  cljc  files in all matching\nconnection buffers, both  clj  and  cljs  (if present).  Simply put - if you're evaluating the code  (+ 2 2)  in a  cljc  file and you\nhave an active Clojure and and active ClojureScript REPL, then the code is going\nto be evaluated 2 times - once for each of them. This behavior might be a bit\nconfusing, but that's what we came up with, when ruminating what was the most\nlogical thing to do out-of-the-box.  This can be modified with  M-x   cider-toggle-connection-buffer  RET . Toggling this once will choose one of the connections as the\nprimary, and successive calls to  M-x   cider-toggle-connection-buffer  RET  will alternate which connection to use. To restore evaluation to\nboth connections, invoke  cider-toggle-connection-buffer  with a prefix argument\n( C-u M-x   cider-toggle-connection-buffer   RET ).  If there is only a Clojure connection, no toggling will happen and a message\nwill inform you that there are no other connections to switch to.", 
            "title": "Working with .cljc files"
        }, 
        {
            "location": "/interactive_programming/", 
            "text": "The idea of interactive programming is at the very heart of CIDER.\n\n\nProgrammers are expected to program in a very dynamic and incremental manner,\nconstantly re-evaluating existing Clojure definitions and adding new ones to\ntheir running applications. You never stop/start a Clojure application while\nusing CIDER - you're constantly interacting with it and changing it.\n\n\nCIDER comes with a handy minor mode called \ncider-mode\n (complementing\n\nclojure-mode\n) that allows you to evaluate code in your Clojure source\nfiles and load it directly in the REPL. \ncider-mode\n is the primary\nway you're supposed to be interacting with your REPL process. If you\nwant to get productive with CIDER, you'll have to get intimately familiar\nwith it.\n\n\nUsing cider-mode\n\n\nHere's a list of \ncider-mode\n's keybindings:\n\n\n\n\n\n\n\n\nCommand\n\n\nKeyboard shortcut\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncider-eval-last-sexp\n\n\nC-x C-e\n \n \nC-c C-e\n\n\nEvaluate the form preceding point and display the result in the echo area and/or in an buffer overlay (according to \ncider-use-overlays\n).  If invoked with a prefix argument, insert the result into the current buffer.\n\n\n\n\n\n\ncider-eval-last-sexp-and-replace\n\n\nC-c C-v w\n\n\nEvaluate the form preceding point and replace it with its result.\n\n\n\n\n\n\ncider-eval-last-sexp-to-repl\n\n\nC-c M-e\n\n\nEvaluate the form preceding point and output it result to the REPL buffer.  If invoked with a prefix argument, takes you to the REPL buffer after being invoked.\n\n\n\n\n\n\ncider-insert-last-sexp-in-repl\n\n\nC-c M-p\n\n\nLoad the form preceding point in the REPL buffer.\n\n\n\n\n\n\ncider-pprint-eval-last-sexp\n\n\nC-c C-p\n\n\nEvaluate the form preceding point and pretty-print the result in a popup buffer. If invoked with a prefix argument, insert the result into the current buffer as a comment.\n\n\n\n\n\n\ncider-pprint-eval-defun-at-point\n\n\nC-c C-f\n\n\nEvaluate the top level form under point and pretty-print the result in a popup buffer. If invoked with a prefix argument, insert the result into the current buffer as a comment.\n\n\n\n\n\n\ncider-eval-defun-at-point\n\n\nC-M-x\n \n \nC-c C-c\n\n\nEvaluate the top level form under point and display the result in the echo area.\n\n\n\n\n\n\ncider-eval-sexp-at-point\n\n\nC-c C-v v\n\n\nEvaluate the form around point.\n\n\n\n\n\n\ncider-eval-defun-at-point\n\n\nC-u C-M-x\n \n \nC-u C-c C-c\n\n\nDebug the top level form under point and walk through its evaluation\n\n\n\n\n\n\ncider-eval-region\n\n\nC-c C-v r\n\n\nEvaluate the region and display the result in the echo area.\n\n\n\n\n\n\ncider-interrupt\n\n\nC-c C-b\n\n\nInterrupt any pending evaluations.\n\n\n\n\n\n\ncider-macroexpand-1\n\n\nC-c C-m\n\n\nInvoke \nmacroexpand-1\n on the form at point and display the result in a macroexpansion buffer.  If invoked with a prefix argument, \nmacroexpand\n is used instead of \nmacroexpand-1\n.\n\n\n\n\n\n\ncider-macroexpand-all\n\n\nC-c M-m\n\n\nInvoke \nclojure.walk/macroexpand-all\n on the form at point and display the result in a macroexpansion buffer.\n\n\n\n\n\n\ncider-eval-ns-form\n\n\nC-c C-v n\n\n\nEval the ns form.\n\n\n\n\n\n\ncider-repl-set-ns\n\n\nC-c M-n\n\n\nSwitch the namespace of the REPL buffer to the namespace of the current buffer.\n\n\n\n\n\n\ncider-switch-to-repl-buffer\n\n\nC-c C-z\n\n\nSwitch to the relevant REPL buffer. Use a prefix argument to change the namespace of the REPL buffer to match the currently visited source file.\n\n\n\n\n\n\ncider-switch-to-repl-buffer\n\n\nC-u C-u C-c C-z\n\n\nSwitch to the REPL buffer based on a user prompt for a directory.\n\n\n\n\n\n\ncider-load-buffer-and-switch-to-repl-buffer\n\n\nC-c M-z\n\n\nLoad (eval) the current buffer and switch to the relevant REPL buffer. Use a prefix argument to change the namespace of the REPL buffer to match the currently visited source file.\n\n\n\n\n\n\ncider-display-connection-info\n\n\nC-c M-d\n\n\nDisplay default REPL connection details, including project directory name, buffer namespace, host and port.\n\n\n\n\n\n\ncider-rotate-default-connection\n\n\nC-c M-r\n\n\nRotate and display the default nREPL connection.\n\n\n\n\n\n\ncider-find-and-clear-repl-output\n\n\nC-c C-o\n\n\nClear the last output in the REPL buffer. With a prefix argument it will clear the entire REPL buffer, leaving only a prompt. Useful if you're running the REPL buffer in a side by side buffer.\n\n\n\n\n\n\ncider-load-buffer\n\n\nC-c C-k\n\n\nLoad (eval) the current buffer.\n\n\n\n\n\n\ncider-load-file\n\n\nC-c C-l\n\n\nLoad (eval) a Clojure file.\n\n\n\n\n\n\ncider-load-all-files\n\n\nC-c C-M-l\n\n\nLoad (eval) all Clojure files below a directory.\n\n\n\n\n\n\ncider-refresh\n\n\nC-c C-x\n\n\nReload all modified files on the classpath. If invoked with a prefix argument, reload all files on the classpath. If invoked with a double prefix argument, clear the state of the namespace tracker before reloading.\n\n\n\n\n\n\ncider-doc\n\n\nC-c C-d d\n \n \nC-c C-d C-d\n\n\nDisplay doc string for the symbol at point.  If invoked with a prefix argument, or no symbol is found at point, prompt for a symbol.\n\n\n\n\n\n\ncider-javadoc\n\n\nC-c C-d j\n \n \nC-c C-d C-j\n\n\nDisplay JavaDoc (in your default browser) for the symbol at point.  If invoked with a prefix argument, or no symbol is found at point, prompt for a symbol.\n\n\n\n\n\n\ncider-grimoire\n\n\nC-c C-d r\n \n \nC-c C-d C-r\n\n\nLookup symbol in Grimoire.\n\n\n\n\n\n\ncider-grimoire-web\n\n\nC-c C-d w\n \n \nC-c C-d C-w\n\n\nOpen the grimoire documentation for symbol in a web browser.\n\n\n\n\n\n\ncider-apropos\n\n\nC-c C-d a\n \n \nC-c C-d C-a\n\n\nApropos search for functions/vars.\n\n\n\n\n\n\ncider-apropos-documentation\n\n\nC-c C-d f\n \n \nC-c C-d C-f\n\n\nApropos search for documentation.\n\n\n\n\n\n\ncider-apropos-documentation-select\n\n\nC-c C-d e\n \n \nC-c C-d C-e\n\n\nApropos search for documentation \n select.\n\n\n\n\n\n\ncider-inspect\n\n\nC-c M-i\n\n\nInspect expression. Will act on expression at point if present.\n\n\n\n\n\n\ncider-toggle-trace-var\n\n\nC-c M-t v\n\n\nToggle var tracing.\n\n\n\n\n\n\ncider-toggle-trace-ns\n\n\nC-c M-t n\n\n\nToggle namespace tracing.\n\n\n\n\n\n\ncider-undef\n\n\nC-c C-u\n\n\nUndefine a symbol. If invoked with a prefix argument, or no symbol is found at point, prompt for a symbol.\n\n\n\n\n\n\ncider-test-run-test\n\n\nC-c C-t t\n \n \nC-c C-t C-t\n\n\nRun test at point.\n\n\n\n\n\n\ncider-test-rerun-test\n\n\nC-c C-t g\n \n \nC-c C-t C-g\n\n\nRe-run the last test you ran.\n\n\n\n\n\n\ncider-test-run-ns-tests\n\n\nC-c C-t n\n \n \nC-c C-t C-n\n\n\nRun tests for current namespace.\n\n\n\n\n\n\ncider-test-run-loaded-tests\n\n\nC-c C-t l\n \n \nC-c C-t C-l\n\n\nRun tests for all loaded namespaces.\n\n\n\n\n\n\ncider-test-run-project-tests\n\n\nC-c C-t p\n \n \nC-c C-t C-p\n\n\nRun tests for all project namespaces. This loads the additional namespaces.\n\n\n\n\n\n\ncider-test-rerun-failed-tests\n\n\nC-c C-t r\n \n \nC-c C-t C-r\n\n\nRe-run test failures/errors.\n\n\n\n\n\n\ncider-test-show-report\n\n\nC-c C-t b\n \n \nC-c C-t C-b\n\n\nShow the test report buffer.\n\n\n\n\n\n\ncider-find-var\n\n\nM-.\n\n\nJump to the definition of a symbol.  If invoked with a prefix argument, or no symbol is found at point, prompt for a symbol.\n\n\n\n\n\n\ncider-find-resource\n\n\nC-c M-.\n\n\nJump to the resource referenced by the string at point.\n\n\n\n\n\n\ncider-find-ns\n\n\nC-c C-.\n\n\nJump to some namespace on the classpath.\n\n\n\n\n\n\ncider-pop-back\n\n\nM-,\n\n\nReturn to your pre-jump location.\n\n\n\n\n\n\ncomplete-symbol\n\n\nM-TAB\n\n\nComplete the symbol at point.\n\n\n\n\n\n\ncider-quit\n\n\nC-c C-q\n\n\nQuit the current nREPL connection. With a prefix argument it will quit all connections.\n\n\n\n\n\n\n\n\nThere's no need to memorize this list. In any Clojure buffer with \ncider-mode\n\nactive you'll have a CIDER menu available, which lists all the most important\ncommands and their keybindings. You can also invoke \nC-h f RET cider-mode\n to\nget a list of the keybindings for \ncider-mode\n.\n\n\n\n\nAn even better solution would be to install \nwhich-key\n, which will\nautomatically show you a list of available keybindings as you start typing some\nkeys. This will simplify your interactions with CIDER quite a lot (especially in\nthe beginning). Here's what you'd see if you typed \nC-c C-d\n in a\nClojure buffer:", 
            "title": "Interactive Programming"
        }, 
        {
            "location": "/interactive_programming/#using-cider-mode", 
            "text": "Here's a list of  cider-mode 's keybindings:     Command  Keyboard shortcut  Description      cider-eval-last-sexp  C-x C-e     C-c C-e  Evaluate the form preceding point and display the result in the echo area and/or in an buffer overlay (according to  cider-use-overlays ).  If invoked with a prefix argument, insert the result into the current buffer.    cider-eval-last-sexp-and-replace  C-c C-v w  Evaluate the form preceding point and replace it with its result.    cider-eval-last-sexp-to-repl  C-c M-e  Evaluate the form preceding point and output it result to the REPL buffer.  If invoked with a prefix argument, takes you to the REPL buffer after being invoked.    cider-insert-last-sexp-in-repl  C-c M-p  Load the form preceding point in the REPL buffer.    cider-pprint-eval-last-sexp  C-c C-p  Evaluate the form preceding point and pretty-print the result in a popup buffer. If invoked with a prefix argument, insert the result into the current buffer as a comment.    cider-pprint-eval-defun-at-point  C-c C-f  Evaluate the top level form under point and pretty-print the result in a popup buffer. If invoked with a prefix argument, insert the result into the current buffer as a comment.    cider-eval-defun-at-point  C-M-x     C-c C-c  Evaluate the top level form under point and display the result in the echo area.    cider-eval-sexp-at-point  C-c C-v v  Evaluate the form around point.    cider-eval-defun-at-point  C-u C-M-x     C-u C-c C-c  Debug the top level form under point and walk through its evaluation    cider-eval-region  C-c C-v r  Evaluate the region and display the result in the echo area.    cider-interrupt  C-c C-b  Interrupt any pending evaluations.    cider-macroexpand-1  C-c C-m  Invoke  macroexpand-1  on the form at point and display the result in a macroexpansion buffer.  If invoked with a prefix argument,  macroexpand  is used instead of  macroexpand-1 .    cider-macroexpand-all  C-c M-m  Invoke  clojure.walk/macroexpand-all  on the form at point and display the result in a macroexpansion buffer.    cider-eval-ns-form  C-c C-v n  Eval the ns form.    cider-repl-set-ns  C-c M-n  Switch the namespace of the REPL buffer to the namespace of the current buffer.    cider-switch-to-repl-buffer  C-c C-z  Switch to the relevant REPL buffer. Use a prefix argument to change the namespace of the REPL buffer to match the currently visited source file.    cider-switch-to-repl-buffer  C-u C-u C-c C-z  Switch to the REPL buffer based on a user prompt for a directory.    cider-load-buffer-and-switch-to-repl-buffer  C-c M-z  Load (eval) the current buffer and switch to the relevant REPL buffer. Use a prefix argument to change the namespace of the REPL buffer to match the currently visited source file.    cider-display-connection-info  C-c M-d  Display default REPL connection details, including project directory name, buffer namespace, host and port.    cider-rotate-default-connection  C-c M-r  Rotate and display the default nREPL connection.    cider-find-and-clear-repl-output  C-c C-o  Clear the last output in the REPL buffer. With a prefix argument it will clear the entire REPL buffer, leaving only a prompt. Useful if you're running the REPL buffer in a side by side buffer.    cider-load-buffer  C-c C-k  Load (eval) the current buffer.    cider-load-file  C-c C-l  Load (eval) a Clojure file.    cider-load-all-files  C-c C-M-l  Load (eval) all Clojure files below a directory.    cider-refresh  C-c C-x  Reload all modified files on the classpath. If invoked with a prefix argument, reload all files on the classpath. If invoked with a double prefix argument, clear the state of the namespace tracker before reloading.    cider-doc  C-c C-d d     C-c C-d C-d  Display doc string for the symbol at point.  If invoked with a prefix argument, or no symbol is found at point, prompt for a symbol.    cider-javadoc  C-c C-d j     C-c C-d C-j  Display JavaDoc (in your default browser) for the symbol at point.  If invoked with a prefix argument, or no symbol is found at point, prompt for a symbol.    cider-grimoire  C-c C-d r     C-c C-d C-r  Lookup symbol in Grimoire.    cider-grimoire-web  C-c C-d w     C-c C-d C-w  Open the grimoire documentation for symbol in a web browser.    cider-apropos  C-c C-d a     C-c C-d C-a  Apropos search for functions/vars.    cider-apropos-documentation  C-c C-d f     C-c C-d C-f  Apropos search for documentation.    cider-apropos-documentation-select  C-c C-d e     C-c C-d C-e  Apropos search for documentation   select.    cider-inspect  C-c M-i  Inspect expression. Will act on expression at point if present.    cider-toggle-trace-var  C-c M-t v  Toggle var tracing.    cider-toggle-trace-ns  C-c M-t n  Toggle namespace tracing.    cider-undef  C-c C-u  Undefine a symbol. If invoked with a prefix argument, or no symbol is found at point, prompt for a symbol.    cider-test-run-test  C-c C-t t     C-c C-t C-t  Run test at point.    cider-test-rerun-test  C-c C-t g     C-c C-t C-g  Re-run the last test you ran.    cider-test-run-ns-tests  C-c C-t n     C-c C-t C-n  Run tests for current namespace.    cider-test-run-loaded-tests  C-c C-t l     C-c C-t C-l  Run tests for all loaded namespaces.    cider-test-run-project-tests  C-c C-t p     C-c C-t C-p  Run tests for all project namespaces. This loads the additional namespaces.    cider-test-rerun-failed-tests  C-c C-t r     C-c C-t C-r  Re-run test failures/errors.    cider-test-show-report  C-c C-t b     C-c C-t C-b  Show the test report buffer.    cider-find-var  M-.  Jump to the definition of a symbol.  If invoked with a prefix argument, or no symbol is found at point, prompt for a symbol.    cider-find-resource  C-c M-.  Jump to the resource referenced by the string at point.    cider-find-ns  C-c C-.  Jump to some namespace on the classpath.    cider-pop-back  M-,  Return to your pre-jump location.    complete-symbol  M-TAB  Complete the symbol at point.    cider-quit  C-c C-q  Quit the current nREPL connection. With a prefix argument it will quit all connections.     There's no need to memorize this list. In any Clojure buffer with  cider-mode \nactive you'll have a CIDER menu available, which lists all the most important\ncommands and their keybindings. You can also invoke  C-h f RET cider-mode  to\nget a list of the keybindings for  cider-mode .   An even better solution would be to install  which-key , which will\nautomatically show you a list of available keybindings as you start typing some\nkeys. This will simplify your interactions with CIDER quite a lot (especially in\nthe beginning). Here's what you'd see if you typed  C-c C-d  in a\nClojure buffer:", 
            "title": "Using cider-mode"
        }, 
        {
            "location": "/using_the_repl/", 
            "text": "CIDER comes with a powerful REPL, which is quite handy when you want to\nexperiment with the code you're working on or just explore some stuff (e.g. a\nlibrary you're playing with).  The REPL offers a number of advanced features:\n\n\n\n\nauto-completion\n\n\nfont-locking (the same as in \nclojure-mode\n)\n\n\nquick access to many CIDER commands (e.g. definition and documentation lookup, tracing, etc)\n\n\n(optional) pretty-printing of evaluation results\n\n\neldoc support\n\n\nhighly customizable REPL prompt\n\n\n\n\nHere's a list of the keybindings that are available in CIDER's REPL:\n\n\n\n\n\n\n\n\nKeyboard shortcut\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nRET\n\n\nEvaluate the current input in Clojure if it is complete. If incomplete, open a new line and indent. If invoked with a prefix argument is given then the input is evaluated without checking for completeness.\n\n\n\n\n\n\nC-RET\n\n\nClose any unmatched parenthesis and then evaluate the current input in Clojure.\n\n\n\n\n\n\nC-j\n\n\nOpen a new line and indent.\n\n\n\n\n\n\nC-c C-o\n\n\nRemove the output of the previous evaluation from the REPL buffer. With a prefix argument it will clear the entire REPL buffer, leaving only a prompt.\n\n\n\n\n\n\nC-c M-o\n\n\nSwitch between the Clojure and ClojureScript REPLs for the current project.\n\n\n\n\n\n\nC-c C-u\n\n\nKill all text from the prompt to the current point.\n\n\n\n\n\n\nC-c C-b\n \n \nC-c C-c\n\n\nInterrupt any pending evaluations.\n\n\n\n\n\n\nC-up\n \n \nC-down\n\n\nGo to to previous/next input in history.\n\n\n\n\n\n\nM-p\n \n \nM-n\n\n\nSearch the previous/next item in history using the current input as search pattern. If \nM-p/M-n\n is typed two times in a row, the second invocation uses the same search pattern (even if the current input has changed).\n\n\n\n\n\n\nM-s\n \n \nM-r\n\n\nSearch forward/reverse through command history with regex.\n\n\n\n\n\n\nC-c C-n\n \n \nC-c C-p\n\n\nMove between the current and previous prompts in the REPL buffer. Pressing \nRET\n on a line with old input copies that line to the newest prompt.\n\n\n\n\n\n\nC-c C-x\n\n\nReload all modified files on the classpath.\n\n\n\n\n\n\nC-u C-c C-x\n\n\nReload all files on the classpath.\n\n\n\n\n\n\nTAB\n\n\nComplete symbol at point.\n\n\n\n\n\n\nC-c C-d d\n \n \nC-c C-d C-d\n\n\nDisplay doc string for the symbol at point.  If invoked with a prefix argument, or no symbol is found at point, prompt for a symbol\n\n\n\n\n\n\nC-c C-d j\n \n \nC-c C-d C-j\n\n\nDisplay JavaDoc (in your default browser) for the symbol at point.  If invoked with a prefix argument, or no symbol is found at point, prompt for a symbol.\n\n\n\n\n\n\nC-c C-d r\n \n \nC-c C-d C-r\n\n\nLookup symbol in Grimoire.\n\n\n\n\n\n\nC-c C-d a\n \n \nC-c C-d C-a\n\n\nApropos search for functions/vars.\n\n\n\n\n\n\nC-c C-d f\n \n \nC-c C-d C-f\n\n\nApropos search for documentation.\n\n\n\n\n\n\nC-c C-z\n\n\nSwitch to the previous Clojure buffer. This complements \nC-c C-z\n used in cider-mode.\n\n\n\n\n\n\nC-c M-i\n\n\nInspect expression. Will act on expression at point if present.\n\n\n\n\n\n\nC-c M-n\n\n\nSelect a namespace and switch to it.\n\n\n\n\n\n\nC-c C-.\n\n\nJump to some namespace on the classpath.\n\n\n\n\n\n\nC-c M-t v\n\n\nToggle var tracing.\n\n\n\n\n\n\nC-c M-t n\n\n\nToggle namespace tracing.\n\n\n\n\n\n\nC-c C-t t\n \n \nC-c C-t C-t\n\n\nRun test at point.\n\n\n\n\n\n\nC-c C-t g\n \n \nC-c C-t C-g\n\n\nRe-run the last test you ran.\n\n\n\n\n\n\nC-c C-t n\n \n \nC-c C-t C-n\n\n\nRun tests for current namespace.\n\n\n\n\n\n\nC-c C-t l\n \n \nC-c C-t C-l\n\n\nRun tests for all loaded namespaces.\n\n\n\n\n\n\nC-c C-t p\n \n \nC-c C-t C-p\n\n\nRun tests for all project namespaces. This loads the additional namespaces.\n\n\n\n\n\n\nC-c C-t r\n \n \nC-c C-t C-r\n\n\nRe-run test failures/errors.\n\n\n\n\n\n\nC-c C-t b\n \n \nC-c C-t C-b\n\n\nShow the test report buffer.\n\n\n\n\n\n\nC-c C-q\n\n\nQuit the current nREPL connection. With a prefix argument it will quit all connections.\n\n\n\n\n\n\n\n\nThere's no need to memorize this list. In any REPL buffer you'll have a \nREPL\n\nmenu available, which lists all the most important commands and their\nkeybindings. You can also invoke \nC-h f RET cider-repl-mode\n to get a list of the\nkeybindings for \ncider-repl-mode\n.\n\n\nIn the REPL you can also use \"shortcut commands\" by pressing \n,\n at the\nbeginning of a REPL line. You'll be presented with a list of commands you can\nquickly run (like quitting, displaying some info, clearing the REPL, etc). The\ncharacter used to trigger the shortcuts is configurable via\n\ncider-repl-shortcut-dispatch-char\n. Here's how you can change it to \n;\n:\n\n\n(setq cider-repl-shortcut-dispatch-char ?\\;)\n\n\n\n\nREPL Configuration\n\n\nBehavior on connect\n\n\nNormally, the REPL buffer is auto-displayed in a separate window after\n  a connection is established. You can suppress this behaviour like this:\n\n\n(setq cider-repl-pop-to-buffer-on-connect nil)\n\n\n\n\nIf you want the REPL buffer to be auto-displayed, but don't want it to be\nfocused, use this:\n\n\n(setq cider-repl-pop-to-buffer-on-connect 'display-only)\n\n\n\n\nBehavior on switch\n\n\nBy default \nC-c C-z\n will display the REPL buffer in a different window.\nYou can make \nC-c C-z\n switch to the CIDER REPL buffer in the current\nwindow:\n\n\n(setq cider-repl-display-in-current-window t)\n\n\n\n\nEldoc\n\n\nEldoc displays function signatures in the minibuffer as you're typing.\nIt's extremely useful! Enable \neldoc\n in REPL buffers like this:\n\n\n(add-hook 'cider-repl-mode-hook #'eldoc-mode)\n\n\n\n\nCustomizing the REPL prompt\n\n\nYou can customize the prompt in REPL buffer. To do that you can customize\n\ncider-repl-prompt-function\n and set it to a function that takes one argument,\na namespace name. For convenience, three functions are already provided:\n\ncider-repl-prompt-lastname\n, \ncider-repl-prompt-abbreviated\n,\n\ncider-repl-prompt-default\n and by default the last one is being used.\nPrompt for each of them for namespace \nleiningen.core.ssl\n:\n\n\n\n\ncider-repl-prompt-lastname\n:\n\n\n\n\nssl\n\n\n\n\ncider-repl-prompt-abbreviated\n:\n\n\n\n\nl.c.ssl\n\n\n\n\ncider-repl-prompt-default\n:\n\n\n\n\nleiningen.core.ssl\n\n\nYou may, of course, write your own function. For example, in \nleiningen\n there\nare two namespaces with similar names - \nleiningen.classpath\n and\n\nleiningen.core.classpath\n. To make them easily recognizable you can either\nuse the default value or you can opt to show only two segments of the\nnamespace and still be able to know which is the REPL's current\nnamespace. Here is an example function that will do exactly that:\n\n\n(defun cider-repl-prompt-show-two (namespace)\n  \nReturn a prompt string with the last 2 segments of NAMESPACE.\n\n  (let ((names (reverse (subseq (reverse (split-string namespace \n\\\\.\n)) 0 2))))\n    (concat (car names) \n.\n (cadr names) \n \n)))\n\n\n\n\nTAB Completion\n\n\nYou can control the \nTAB\n key behavior in the REPL via the\n\ncider-repl-tab-command\n variable.  While the default command\n\ncider-repl-indent-and-complete-symbol\n should be an adequate choice for\nmost users, it's very easy to switch to another command if you wish\nto. For instance if you'd like \nTAB\n to only indent (maybe\nbecause you're used to completing with \nM-TAB\n) use the\nfollowing snippet:\n\n\n(setq cider-repl-tab-command #'indent-for-tab-command)\n\n\n\n\nResult Prefix\n\n\nChange the result prefix for REPL evaluation (by default there's no prefix):\n\n\n(setq cider-repl-result-prefix \n;; =\n \n)\n\n\n\n\nAnd here's the result of that change:\n\n\nuser\n (+ 1 2)\n;; =\n 3\n\n\n\n\nCustomize the REPL Buffer's Name\n\n\nThe REPL buffer name has the format \n*cider-repl project-name*\n.\nYou can change the separator from space to something else by overriding \nnrepl-buffer-name-separator\n.\n\n\n(setq nrepl-buffer-name-separator \n-\n)\n\n\n\n\nThe REPL buffer name can also display the port on which the nREPL server is running.\nBuffer name will look like \n*cider-repl project-name:port*\n.\n\n\n(setq nrepl-buffer-name-show-port t)\n\n\n\n\nFont-locking\n\n\nNormally code in the REPL is font-locked the same way as in\n\nclojure-mode\n. Before CIDER 0.10 by default REPL input was font-locked with\n\ncider-repl-input-face\n (after you press \nRET\n) and results were font-locked with\n\ncider-repl-result-face\n. If you want to restore the old behaviour use:\n\n\n(setq cider-repl-use-clojure-font-lock nil)\n\n\n\n\nPretty printing in the REPL\n\n\nMake the REPL always pretty-print the results of your evaluations.\n\n\nM-x cider-repl-toggle-pretty-printing\n\n\nTo make this behavior the default:\n\n\n(setq cider-repl-use-pretty-printing t)\n\n\n\n\nLimiting printed output in the REPL\n\n\nAccidentally printing large objects can be detrimental to your\nproductivity. Clojure provides the \n*print-length*\n var which, if set,\ncontrols how many items of each collection the printer will print. You\ncan supply a default value for REPL sessions via the \nrepl-options\n\nsection of your Leiningen project's configuration.\n\n\n:repl-options {:init (set! *print-length* 50)}\n\n\n\n\nREPL history\n\n\n\n\nTo make the REPL history wrap around when its end is reached:\n\n\n\n\n(setq cider-repl-wrap-history t)\n\n\n\n\n\n\nTo adjust the maximum number of items kept in the REPL history:\n\n\n\n\n(setq cider-repl-history-size 1000) ; the default is 500\n\n\n\n\n\n\nTo store the REPL history in a file:\n\n\n\n\n(setq cider-repl-history-file \npath/to/file\n)\n\n\n\n\nNote that the history is written to the file when you kill the REPL\nbuffer (which includes invoking \ncider-quit\n) or you quit Emacs.\n\n\nREPL history browser\n\n\nYou can browse your REPL input history with the command \nM-x\n\n\ncider-repl-history\n.  It is also bound in \ncider-repl-mode\n buffers to\n\nC-c M-p\n, and is also available via the \nhistory\n shortcut.\n\n\nThe history is displayed in order, with the most recent input at the top of the\nbuffer, and the oldest one at the bottom.  You can scroll through the history,\nand when you find the history item you were looking for, you can insert it from\nthe history buffer into your REPL buffer.\n\n\n\n\nMode\n\n\nThe history buffer has its own major mode, \ncider-repl-history-mode\n which is derived\nfrom \nclojure-mode\n, so you get fontification in the history buffer. It supports\nthe expected defcustom hook variable, \ncider-repl-history-hook\n.\n\n\nInsertion\n\n\nTypically your cursor will be at the bottom of the REPL buffer (\npoint-max\n)\nwhen you use this feature; if that's the case, the text is inserted, and point\nis advanced to the end of the inserted text. In the unusual case where you\ninvoke the history browser when your cursor is \nnot\n at the end of the buffer,\nthe text is \nstill\n inserted at point-max, but point is not modified.\n\n\nThe text is inserted without a final newline, meaning you can edit the form\nif you wish, and you must explicitly hit \nEnter\n to have it evaluated\nby the REPL.\n\n\nQuitting\n\n\nAfter text is inserted, the history buffer is automatically quit. If you decide\nyou don't want to insert any text after all, you can explicitly quit by running\n\ncider-repl-history-quit\n (see keyboard shortcuts).  Due to the initialization and\ncleanup done, it is better to properly quit, rather than just switch away from\nthe history buffer.\n\n\nWhen you quit the history buffer, there are several different ways for the\nbuffers and windows to be restored. This is controlled by the custom variable\n\ncider-repl-history-quit-action\n, which can be assigned one of several values:\n\n\n\n\nquit-window\n restores the window configuration to what it was before.\n  This is the default.\n\n\ndelete-and-restore\n restores the window configuration to what it was before,\n  and kills the \n*cider-repl-history*\n buffer.\n\n\nkill-and-delete-window\n kills the \n*cider-repl-history*\n buffer, and\n  deletes the window.\n\n\nbury-buffer\n simply buries the \n*cider-repl-history*\n buffer, but keeps the\n  window.\n\n\nbury-and-delete-window\n buries the buffer, and (if there is more than one\n  window) deletes the window.\n\n\nany other value is interpreted as the name of a function to call\n\n\n\n\nFiltering\n\n\nBy invoking \ncider-repl-history-occur\n from the history buffer, you will be prompted\nfor a regular expression, and the history buffer will be filtered to only those\ninputs that match the regexp.\n\n\nPreview and Highlight\n\n\nWhen \ncider-repl-history-show-preview\n is non-nil, we display an [\noverlay\n]\n(https://www.gnu.org/software/emacs/manual/html_node/elisp/Overlays.html)\nof the currently selected history entry, in the REPL buffer.\n\n\nThis is a nice feature; the only thing to be careful of is that if you do not\nproperly quit from browsing the history (i.e., if you just \nC-x b\n\naway from the buffer), you may be left with an unwanted overlay in your REPL\nbuffer. It can be eliminated with \nM-x\n \ncider-repl-history-clear-preview\n.\n\n\nBy default, the variable is nil and the feature is off.\n\n\nA related feature is to highlight the entry once it is actually inserted into\nthe REPL buffer. This is controlled by the variable\n\ncider-repl-history-highlight-inserted-item\n. The non-nil value selected controls how\nthe inserted item is highlighted, possible values are \nsolid\n (highlight the\ninserted text for a fixed period of time), or \npulse\n (fade out the highlighting\ngradually).  Setting this variable to the value t will select the default\nhighlighting style, which currently \npulse\n. Default is nil.\n\n\nWhen \"highlight-inserted\" is turned on, you can customize the face of the\ninserted text with the variable \ncider-repl-history-inserted-item-face\n.\n\n\nAdditional Customization\n\n\nThere are quite a few customizations available, in addition to the ones\nalready mentioned.\n\n\n\n\ncider-repl-history-display-duplicates\n - when set to \nnil\n, will not display any\n  duplicate entries in the history buffer.  Default is \nt\n.\n\n\ncider-repl-history-display-duplicate-highest\n - when not displaying duplicates,\n  this controls where in the history the one instance of the duplicated text\n  is displayed. When \nt\n, it displays the entry in the highest position\n  applicable; when \nnil\n, it displays it in the lowest position.\n\n\ncider-repl-history-display-style\n - the history entries will often be more than\n   one line. The package gives you two options for displaying the entries:\n\n\nseparated\n - a separator string is inserted between entries; entries\n  may span multiple lines.  This is the default.\n\n\none-line\n - any newlines are replaced with literal \n\\n\n strings, and\n  therefore no separator is necessary. Each \n\\n\n becomes a proper newline\n  when the text is inserted into the REPL.\n\n\n\n\n\n\ncider-repl-history-separator\n - when \ncider-repl-history-display-style\n is \nseparated\n,\n  this gives the text to use as the separator. The default is a series of ten\n  semicolons, which is, of course, a comment in Clojure. The separator could be\n  anything, but it may screw up the fontification if you make it something weird.\n\n\ncider-repl-history-separator-face\n - specifies the face for the separator.\n\n\ncider-repl-history-maximum-display-length\n - when nil (the default), all history\n  items are displayed in full. If you prefer to have long items abbreviated,\n  you can set this variable to an integer, and each item will be limited to that\n  many characters. (This variable does not affect the number of items displayed,\n  only the maximum length of each item.)\n\n\ncider-repl-history-recenter\n - when non-nil, always keep the current entry at the\n  top of the history window.  Default is nil.\n\n\ncider-repl-history-resize-window\n - whether to resize the history window to fit\n  its contents.  Value is either t, meaning yes, or a cons pair of integers,\n  (MAXIMUM . MINIMUM) for the size of the window. MAXIMUM defaults to the window\n  size chosen by \npop-to-buffer\n; MINIMUM defaults to \nwindow-min-height\n.\n\n\ncider-repl-history-highlight-current-entry\n - if non-nil, highlight the currently\n  selected entry in the history buffer.  Default is nil.\n\n\ncider-repl-history-current-entry-face\n - specifies the face for the history-entry\n  highlight.\n\n\ncider-repl-history-text-properties\n - when set to \nt\n, maintains Emacs text\n  properties on the entry. Default is \nnil\n.\n\n\n\n\nKey Bindings\n\n\nThere are a number of important keybindings in history buffers.\n\n\n\n\n\n\n\n\nKeyboard shortcut\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nn\n\n\nGo to next (lower, older) item in the history.\n\n\n\n\n\n\np\n\n\nGo to previous (higher, more recent) item in the history.\n\n\n\n\n\n\nRET\n or \nSPC\n\n\nInsert history item (at point) at the end of the REPL buffer, and quit.\n\n\n\n\n\n\nl\n (lower-case L)\n\n\nFilter the command history (see \nFiltering\n, above).\n\n\n\n\n\n\ns\n\n\nRegexp search forward.\n\n\n\n\n\n\nr\n\n\nRegexp search backward.\n\n\n\n\n\n\nq\n\n\nQuit (and take quit action).\n\n\n\n\n\n\nU\n\n\nUndo in the REPL buffer.", 
            "title": "Using the REPL"
        }, 
        {
            "location": "/using_the_repl/#repl-configuration", 
            "text": "", 
            "title": "REPL Configuration"
        }, 
        {
            "location": "/using_the_repl/#behavior-on-connect", 
            "text": "Normally, the REPL buffer is auto-displayed in a separate window after\n  a connection is established. You can suppress this behaviour like this:  (setq cider-repl-pop-to-buffer-on-connect nil)  If you want the REPL buffer to be auto-displayed, but don't want it to be\nfocused, use this:  (setq cider-repl-pop-to-buffer-on-connect 'display-only)", 
            "title": "Behavior on connect"
        }, 
        {
            "location": "/using_the_repl/#behavior-on-switch", 
            "text": "By default  C-c C-z  will display the REPL buffer in a different window.\nYou can make  C-c C-z  switch to the CIDER REPL buffer in the current\nwindow:  (setq cider-repl-display-in-current-window t)", 
            "title": "Behavior on switch"
        }, 
        {
            "location": "/using_the_repl/#eldoc", 
            "text": "Eldoc displays function signatures in the minibuffer as you're typing.\nIt's extremely useful! Enable  eldoc  in REPL buffers like this:  (add-hook 'cider-repl-mode-hook #'eldoc-mode)", 
            "title": "Eldoc"
        }, 
        {
            "location": "/using_the_repl/#customizing-the-repl-prompt", 
            "text": "You can customize the prompt in REPL buffer. To do that you can customize cider-repl-prompt-function  and set it to a function that takes one argument,\na namespace name. For convenience, three functions are already provided: cider-repl-prompt-lastname ,  cider-repl-prompt-abbreviated , cider-repl-prompt-default  and by default the last one is being used.\nPrompt for each of them for namespace  leiningen.core.ssl :   cider-repl-prompt-lastname :   ssl   cider-repl-prompt-abbreviated :   l.c.ssl   cider-repl-prompt-default :   leiningen.core.ssl  You may, of course, write your own function. For example, in  leiningen  there\nare two namespaces with similar names -  leiningen.classpath  and leiningen.core.classpath . To make them easily recognizable you can either\nuse the default value or you can opt to show only two segments of the\nnamespace and still be able to know which is the REPL's current\nnamespace. Here is an example function that will do exactly that:  (defun cider-repl-prompt-show-two (namespace)\n   Return a prompt string with the last 2 segments of NAMESPACE. \n  (let ((names (reverse (subseq (reverse (split-string namespace  \\\\. )) 0 2))))\n    (concat (car names)  .  (cadr names)    )))", 
            "title": "Customizing the REPL prompt"
        }, 
        {
            "location": "/using_the_repl/#tab-completion", 
            "text": "You can control the  TAB  key behavior in the REPL via the cider-repl-tab-command  variable.  While the default command cider-repl-indent-and-complete-symbol  should be an adequate choice for\nmost users, it's very easy to switch to another command if you wish\nto. For instance if you'd like  TAB  to only indent (maybe\nbecause you're used to completing with  M-TAB ) use the\nfollowing snippet:  (setq cider-repl-tab-command #'indent-for-tab-command)", 
            "title": "TAB Completion"
        }, 
        {
            "location": "/using_the_repl/#result-prefix", 
            "text": "Change the result prefix for REPL evaluation (by default there's no prefix):  (setq cider-repl-result-prefix  ;; =   )  And here's the result of that change:  user  (+ 1 2)\n;; =  3", 
            "title": "Result Prefix"
        }, 
        {
            "location": "/using_the_repl/#customize-the-repl-buffers-name", 
            "text": "The REPL buffer name has the format  *cider-repl project-name* .\nYou can change the separator from space to something else by overriding  nrepl-buffer-name-separator .  (setq nrepl-buffer-name-separator  - )  The REPL buffer name can also display the port on which the nREPL server is running.\nBuffer name will look like  *cider-repl project-name:port* .  (setq nrepl-buffer-name-show-port t)", 
            "title": "Customize the REPL Buffer's Name"
        }, 
        {
            "location": "/using_the_repl/#font-locking", 
            "text": "Normally code in the REPL is font-locked the same way as in clojure-mode . Before CIDER 0.10 by default REPL input was font-locked with cider-repl-input-face  (after you press  RET ) and results were font-locked with cider-repl-result-face . If you want to restore the old behaviour use:  (setq cider-repl-use-clojure-font-lock nil)", 
            "title": "Font-locking"
        }, 
        {
            "location": "/using_the_repl/#pretty-printing-in-the-repl", 
            "text": "Make the REPL always pretty-print the results of your evaluations.  M-x cider-repl-toggle-pretty-printing  To make this behavior the default:  (setq cider-repl-use-pretty-printing t)", 
            "title": "Pretty printing in the REPL"
        }, 
        {
            "location": "/using_the_repl/#limiting-printed-output-in-the-repl", 
            "text": "Accidentally printing large objects can be detrimental to your\nproductivity. Clojure provides the  *print-length*  var which, if set,\ncontrols how many items of each collection the printer will print. You\ncan supply a default value for REPL sessions via the  repl-options \nsection of your Leiningen project's configuration.  :repl-options {:init (set! *print-length* 50)}", 
            "title": "Limiting printed output in the REPL"
        }, 
        {
            "location": "/using_the_repl/#repl-history", 
            "text": "To make the REPL history wrap around when its end is reached:   (setq cider-repl-wrap-history t)   To adjust the maximum number of items kept in the REPL history:   (setq cider-repl-history-size 1000) ; the default is 500   To store the REPL history in a file:   (setq cider-repl-history-file  path/to/file )  Note that the history is written to the file when you kill the REPL\nbuffer (which includes invoking  cider-quit ) or you quit Emacs.", 
            "title": "REPL history"
        }, 
        {
            "location": "/using_the_repl/#repl-history-browser", 
            "text": "You can browse your REPL input history with the command  M-x  cider-repl-history .  It is also bound in  cider-repl-mode  buffers to C-c M-p , and is also available via the  history  shortcut.  The history is displayed in order, with the most recent input at the top of the\nbuffer, and the oldest one at the bottom.  You can scroll through the history,\nand when you find the history item you were looking for, you can insert it from\nthe history buffer into your REPL buffer.", 
            "title": "REPL history browser"
        }, 
        {
            "location": "/using_the_repl/#mode", 
            "text": "The history buffer has its own major mode,  cider-repl-history-mode  which is derived\nfrom  clojure-mode , so you get fontification in the history buffer. It supports\nthe expected defcustom hook variable,  cider-repl-history-hook .", 
            "title": "Mode"
        }, 
        {
            "location": "/using_the_repl/#insertion", 
            "text": "Typically your cursor will be at the bottom of the REPL buffer ( point-max )\nwhen you use this feature; if that's the case, the text is inserted, and point\nis advanced to the end of the inserted text. In the unusual case where you\ninvoke the history browser when your cursor is  not  at the end of the buffer,\nthe text is  still  inserted at point-max, but point is not modified.  The text is inserted without a final newline, meaning you can edit the form\nif you wish, and you must explicitly hit  Enter  to have it evaluated\nby the REPL.", 
            "title": "Insertion"
        }, 
        {
            "location": "/using_the_repl/#quitting", 
            "text": "After text is inserted, the history buffer is automatically quit. If you decide\nyou don't want to insert any text after all, you can explicitly quit by running cider-repl-history-quit  (see keyboard shortcuts).  Due to the initialization and\ncleanup done, it is better to properly quit, rather than just switch away from\nthe history buffer.  When you quit the history buffer, there are several different ways for the\nbuffers and windows to be restored. This is controlled by the custom variable cider-repl-history-quit-action , which can be assigned one of several values:   quit-window  restores the window configuration to what it was before.\n  This is the default.  delete-and-restore  restores the window configuration to what it was before,\n  and kills the  *cider-repl-history*  buffer.  kill-and-delete-window  kills the  *cider-repl-history*  buffer, and\n  deletes the window.  bury-buffer  simply buries the  *cider-repl-history*  buffer, but keeps the\n  window.  bury-and-delete-window  buries the buffer, and (if there is more than one\n  window) deletes the window.  any other value is interpreted as the name of a function to call", 
            "title": "Quitting"
        }, 
        {
            "location": "/using_the_repl/#filtering", 
            "text": "By invoking  cider-repl-history-occur  from the history buffer, you will be prompted\nfor a regular expression, and the history buffer will be filtered to only those\ninputs that match the regexp.", 
            "title": "Filtering"
        }, 
        {
            "location": "/using_the_repl/#preview-and-highlight", 
            "text": "When  cider-repl-history-show-preview  is non-nil, we display an [ overlay ]\n(https://www.gnu.org/software/emacs/manual/html_node/elisp/Overlays.html)\nof the currently selected history entry, in the REPL buffer.  This is a nice feature; the only thing to be careful of is that if you do not\nproperly quit from browsing the history (i.e., if you just  C-x b \naway from the buffer), you may be left with an unwanted overlay in your REPL\nbuffer. It can be eliminated with  M-x   cider-repl-history-clear-preview .  By default, the variable is nil and the feature is off.  A related feature is to highlight the entry once it is actually inserted into\nthe REPL buffer. This is controlled by the variable cider-repl-history-highlight-inserted-item . The non-nil value selected controls how\nthe inserted item is highlighted, possible values are  solid  (highlight the\ninserted text for a fixed period of time), or  pulse  (fade out the highlighting\ngradually).  Setting this variable to the value t will select the default\nhighlighting style, which currently  pulse . Default is nil.  When \"highlight-inserted\" is turned on, you can customize the face of the\ninserted text with the variable  cider-repl-history-inserted-item-face .", 
            "title": "Preview and Highlight"
        }, 
        {
            "location": "/using_the_repl/#additional-customization", 
            "text": "There are quite a few customizations available, in addition to the ones\nalready mentioned.   cider-repl-history-display-duplicates  - when set to  nil , will not display any\n  duplicate entries in the history buffer.  Default is  t .  cider-repl-history-display-duplicate-highest  - when not displaying duplicates,\n  this controls where in the history the one instance of the duplicated text\n  is displayed. When  t , it displays the entry in the highest position\n  applicable; when  nil , it displays it in the lowest position.  cider-repl-history-display-style  - the history entries will often be more than\n   one line. The package gives you two options for displaying the entries:  separated  - a separator string is inserted between entries; entries\n  may span multiple lines.  This is the default.  one-line  - any newlines are replaced with literal  \\n  strings, and\n  therefore no separator is necessary. Each  \\n  becomes a proper newline\n  when the text is inserted into the REPL.    cider-repl-history-separator  - when  cider-repl-history-display-style  is  separated ,\n  this gives the text to use as the separator. The default is a series of ten\n  semicolons, which is, of course, a comment in Clojure. The separator could be\n  anything, but it may screw up the fontification if you make it something weird.  cider-repl-history-separator-face  - specifies the face for the separator.  cider-repl-history-maximum-display-length  - when nil (the default), all history\n  items are displayed in full. If you prefer to have long items abbreviated,\n  you can set this variable to an integer, and each item will be limited to that\n  many characters. (This variable does not affect the number of items displayed,\n  only the maximum length of each item.)  cider-repl-history-recenter  - when non-nil, always keep the current entry at the\n  top of the history window.  Default is nil.  cider-repl-history-resize-window  - whether to resize the history window to fit\n  its contents.  Value is either t, meaning yes, or a cons pair of integers,\n  (MAXIMUM . MINIMUM) for the size of the window. MAXIMUM defaults to the window\n  size chosen by  pop-to-buffer ; MINIMUM defaults to  window-min-height .  cider-repl-history-highlight-current-entry  - if non-nil, highlight the currently\n  selected entry in the history buffer.  Default is nil.  cider-repl-history-current-entry-face  - specifies the face for the history-entry\n  highlight.  cider-repl-history-text-properties  - when set to  t , maintains Emacs text\n  properties on the entry. Default is  nil .", 
            "title": "Additional Customization"
        }, 
        {
            "location": "/using_the_repl/#key-bindings", 
            "text": "There are a number of important keybindings in history buffers.     Keyboard shortcut  Description      n  Go to next (lower, older) item in the history.    p  Go to previous (higher, more recent) item in the history.    RET  or  SPC  Insert history item (at point) at the end of the REPL buffer, and quit.    l  (lower-case L)  Filter the command history (see  Filtering , above).    s  Regexp search forward.    r  Regexp search backward.    q  Quit (and take quit action).    U  Undo in the REPL buffer.", 
            "title": "Key Bindings"
        }, 
        {
            "location": "/code_completion/", 
            "text": "CIDER provides intelligent code completion for both source buffers (powered by\n\ncider-mode\n) and REPL buffers.\n\n\nInternally CIDER leverages\n\ncompliment\n for Clojure and\n\ncljs-tooling\n for ClojureScript.\nImprovements to the two libraries automatically translate to improvements in CIDER.\n\n\nStandard completion\n\n\nOut-of-the box CIDER uses the standard Emacs tooling for code completion. When you\npress \nTAB\n or \nM-TAB\n you'll get completion candidates in a\ndedicated buffer.\n\n\n\n\nAuto-completion\n\n\nCIDER users are advised to use \ncompany-mode\n\nto enable auto-completion inside of source code and REPL buffers.  To install\n\ncompany-mode\n do:\n\n\nM-x\n \npackage-install\n \nRET\n \ncompany\n \nRET\n\n\nAfter installation, company can be turned on  globally, like so --\n\n\n(global-company-mode)\n\n\n\n\n-- or through mode-specific hooks:\n\n\n(add-hook 'cider-repl-mode-hook #'company-mode)\n(add-hook 'cider-mode-hook #'company-mode)\n\n\n\n\nWhen \ncompany-mode\n is thus enabled, it will receive completion information\nfrom \ncider-complete-at-point\n, and requires no additional setup or plugins.\n\n\nIf you'd prefer to trigger completions manually you can add this to you config:\n\n\n(setq company-idle-delay nil) ; never start completions automatically\n(global-set-key (kbd \nM-TAB\n) #'company-complete) ; use M-TAB, a.k.a. C-M-i, as manual trigger\n\n\n\n\nTo make \nTAB\n complete, without losing the ability to manually indent,\nyou can add this to your config:\n\n\n(global-set-key (kbd \nTAB\n) #'company-indent-or-complete-common)\n\n\n\n\ncompany-indent-or-complete-common\n is available only in \ncompany-mode\n 0.9+ (at\nthe time of this writing it's still in development).\n\n\nFuzzy candidate matching\n\n\nBy default \ncompany-mode\n will provide completion candidates with the assumption\nthat whatever you've typed so far (e.g. \nmap-\n) is a completion prefix (meaning\nyou'd get only candidates that have \nmap-\n in the beginnings of their names).\nYou can get enhanced fuzzy completion with the CIDER-specific completion style\nby adding:\n\n\n(add-hook 'cider-repl-mode-hook #'cider-company-enable-fuzzy-completion)\n(add-hook 'cider-mode-hook #'cider-company-enable-fuzzy-completion)\n\n\n\n\nNow \ncompany-mode\n will accept certain fuzziness when matching candidates\nagainst the prefix. For example, typing \nmp\n will show you \nmap-indexed\n as one\nof the possible completion candidates, \ncji\n will complete to \nclojure.java.io\n,\netc. Different completion examples are\nlisted \nhere\n.\n\n\nCompletion annotations\n\n\nCompletion candidates will be annotated by default with an abbreviation\ncorresponding to their type, and (contextually) their namespace. The function\nused to format the annotation can be configured by\n\ncider-annotate-completion-function.\n The abbreviations used are configured by\n\ncider-completion-annotations-alist\n and the context in which their namespace is\nincluded is configured by \ncider-completion-annotations-include-ns.\n\n\nCompletion annotations can be disabled by setting\n\ncider-annotate-completion-candidates\n to \nnil\n.\n\n\n\n\nUpdating stale classes and methods cache\n\n\nSometimes, the completion fails to recognize new classes that came with\ndependencies that were loaded dynamically after the REPL has started (e.g. via\nBoot). Executing \nM-x cider-completion-flush-caches\n (or going through the menu\n\nCIDER Interaction-\nMisc-\nFlush completion cache\n) forces the completion backend\nto re-read all classes it can find on the classpath.\n\n\nMigrating from \nauto-complete-mode\n\n\nIn case you have some \nauto-complete-mode\n configuration lying around and you\nwant to switch to \ncompany-mode\n there are a few steps you have to take:\n\n\n\n\n\n\nDisable \nac-cider-setup\n or \nac-nrepl-setup\n from running on CIDER hooks\n\n\n\n\n\n\nRemove \ncider-mode\n and \ncider-repl-mode\n from the \nac-modes\n list", 
            "title": "Code Completion"
        }, 
        {
            "location": "/code_completion/#standard-completion", 
            "text": "Out-of-the box CIDER uses the standard Emacs tooling for code completion. When you\npress  TAB  or  M-TAB  you'll get completion candidates in a\ndedicated buffer.", 
            "title": "Standard completion"
        }, 
        {
            "location": "/code_completion/#auto-completion", 
            "text": "CIDER users are advised to use  company-mode \nto enable auto-completion inside of source code and REPL buffers.  To install company-mode  do:  M-x   package-install   RET   company   RET  After installation, company can be turned on  globally, like so --  (global-company-mode)  -- or through mode-specific hooks:  (add-hook 'cider-repl-mode-hook #'company-mode)\n(add-hook 'cider-mode-hook #'company-mode)  When  company-mode  is thus enabled, it will receive completion information\nfrom  cider-complete-at-point , and requires no additional setup or plugins.  If you'd prefer to trigger completions manually you can add this to you config:  (setq company-idle-delay nil) ; never start completions automatically\n(global-set-key (kbd  M-TAB ) #'company-complete) ; use M-TAB, a.k.a. C-M-i, as manual trigger  To make  TAB  complete, without losing the ability to manually indent,\nyou can add this to your config:  (global-set-key (kbd  TAB ) #'company-indent-or-complete-common)  company-indent-or-complete-common  is available only in  company-mode  0.9+ (at\nthe time of this writing it's still in development).", 
            "title": "Auto-completion"
        }, 
        {
            "location": "/code_completion/#fuzzy-candidate-matching", 
            "text": "By default  company-mode  will provide completion candidates with the assumption\nthat whatever you've typed so far (e.g.  map- ) is a completion prefix (meaning\nyou'd get only candidates that have  map-  in the beginnings of their names).\nYou can get enhanced fuzzy completion with the CIDER-specific completion style\nby adding:  (add-hook 'cider-repl-mode-hook #'cider-company-enable-fuzzy-completion)\n(add-hook 'cider-mode-hook #'cider-company-enable-fuzzy-completion)  Now  company-mode  will accept certain fuzziness when matching candidates\nagainst the prefix. For example, typing  mp  will show you  map-indexed  as one\nof the possible completion candidates,  cji  will complete to  clojure.java.io ,\netc. Different completion examples are\nlisted  here .", 
            "title": "Fuzzy candidate matching"
        }, 
        {
            "location": "/code_completion/#completion-annotations", 
            "text": "Completion candidates will be annotated by default with an abbreviation\ncorresponding to their type, and (contextually) their namespace. The function\nused to format the annotation can be configured by cider-annotate-completion-function.  The abbreviations used are configured by cider-completion-annotations-alist  and the context in which their namespace is\nincluded is configured by  cider-completion-annotations-include-ns.  Completion annotations can be disabled by setting cider-annotate-completion-candidates  to  nil .", 
            "title": "Completion annotations"
        }, 
        {
            "location": "/code_completion/#updating-stale-classes-and-methods-cache", 
            "text": "Sometimes, the completion fails to recognize new classes that came with\ndependencies that were loaded dynamically after the REPL has started (e.g. via\nBoot). Executing  M-x cider-completion-flush-caches  (or going through the menu CIDER Interaction- Misc- Flush completion cache ) forces the completion backend\nto re-read all classes it can find on the classpath.", 
            "title": "Updating stale classes and methods cache"
        }, 
        {
            "location": "/code_completion/#migrating-from-auto-complete-mode", 
            "text": "In case you have some  auto-complete-mode  configuration lying around and you\nwant to switch to  company-mode  there are a few steps you have to take:    Disable  ac-cider-setup  or  ac-nrepl-setup  from running on CIDER hooks    Remove  cider-mode  and  cider-repl-mode  from the  ac-modes  list", 
            "title": "Migrating from auto-complete-mode"
        }, 
        {
            "location": "/navigating_stacktraces/", 
            "text": "CIDER comes with a powerful solution to the problem of verbose Clojure\nstacktraces.  Stacktraces are presented in a special major mode\n(\ncider-stacktrace-mode\n), which gives you the possibility to filter out certain\nstack frames and some handy ways to navigate causes.  You'll also be able to go\nto the code in question with a single keystroke.\n\n\n\n\n\n\n\n\nCommand\n\n\nKeyboard shortcut\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncider-stacktrace-previous-cause\n\n\nM-p\n\n\nMove point to previous cause\n\n\n\n\n\n\ncider-stacktrace-next-cause\n\n\nM-n\n\n\nMove point to next cause\n\n\n\n\n\n\ncider-stacktrace-jump\n\n\nM-.\n or \nReturn\n\n\nNavigate to the source location (if available) for the stacktrace frame\n\n\n\n\n\n\ncider-stacktrace-cycle-current-cause\n\n\nTab\n\n\nCycle current cause detail\n\n\n\n\n\n\ncider-stacktrace-cycle-all-causes\n\n\n0\n or \nS-Tab\n\n\nCycle all cause detail\n\n\n\n\n\n\ncider-stacktrace-cycle-cause-1\n\n\n1\n\n\nCycle cause #1 detail\n\n\n\n\n\n\ncider-stacktrace-cycle-cause-2\n\n\n2\n\n\nCycle cause #2 detail\n\n\n\n\n\n\ncider-stacktrace-cycle-cause-3\n\n\n3\n\n\nCycle cause #3 detail\n\n\n\n\n\n\ncider-stacktrace-cycle-cause-4\n\n\n4\n\n\nCycle cause #4 detail\n\n\n\n\n\n\ncider-stacktrace-cycle-cause-5\n\n\n5\n\n\nCycle cause #5 detail\n\n\n\n\n\n\ncider-stacktrace-toggle-java\n\n\nj\n\n\nToggle display of Java frames\n\n\n\n\n\n\ncider-stacktrace-toggle-clj\n\n\nc\n\n\nToggle display of Clojure frames\n\n\n\n\n\n\ncider-stacktrace-toggle-repl\n\n\nr\n\n\nToggle display of REPL frames\n\n\n\n\n\n\ncider-stacktrace-toggle-tooling\n\n\nt\n\n\nToggle display of tooling frames (e.g. compiler, nREPL middleware)\n\n\n\n\n\n\ncider-stacktrace-toggle-duplicates\n\n\nd\n\n\nToggle display of duplicate frames\n\n\n\n\n\n\n`cider-stacktrace-show-only-project\n\n\np\n\n\nToggle display only project frames\n\n\n\n\n\n\ncider-stacktrace-toggle-all\n\n\na\n\n\nToggle display of all frames\n\n\n\n\n\n\n\n\nYou can configure whether the error buffer with stacktraces should be automatically\nshown on error. By default it will be displayed, but you can change this:\n\n\n(setq cider-show-error-buffer nil)\n\n\n\n\nAt times, the error being displayed will originate from a bug in the\nCIDER code itself. These internal errors might frequently occur and\ninterrupt your workflow, but you might not want to suppress \nall\n\nstacktrace buffers via the \ncider-show-error-buffer\n variable as\nabove; instead, you might only want to suppress \nthis specific type\n\nof internal error. The stacktrace buffers provide such an option when\ndisplaying an internal error. A toggle button will be displayed with\nthe error type's name, and you can toggle whether this particular type\nof error will cause the stacktrace buffer to automatically show\nitself.  The toggle button controls this behavior only during the\ncurrent Emacs session, but if you would like to make the suppression\nmore permanent, you can do so by customizing the\n\ncider-stacktrace-suppressed-errors\n variable.  The buffer will also\nprovide a direct link to the bug reporting page to help facilitate its\ndiagnosis and repair.\n\n\nIndependently of the value of \ncider-show-error-buffer\n or \ncider-stacktrace-suppressed-errors\n,\nthe error buffer is always generated in the background. Use \ncider-visit-error-buffer\n to visit\nthis buffer.\n\n\nThere are two more selective strategies for the error buffer:\n\n\n(setq cider-show-error-buffer 'except-in-repl) ; or\n(setq cider-show-error-buffer 'only-in-repl)\n\n\n\n\n\n\nTo disable auto-selection of the error buffer when it's displayed:\n\n\n\n\n(setq cider-auto-select-error-buffer nil)\n\n\n\n\n\n\nError buffer stacktraces may be filtered by default. Valid filter types\ninclude \njava\n, \nclj\n, \nrepl\n, \ntooling\n, and \ndup\n. Setting this to \nnil\n will\nshow all stacktrace frames.\n\n\n\n\n(setq cider-stacktrace-default-filters '(tooling dup))\n\n\n\n\n\n\nError messages may be wrapped for readability. If this value is nil, messages\nwill not be wrapped; if it is truthy but non-numeric, the default \nfill-column\n\nwill be used.\n\n\n\n\n(setq cider-stacktrace-fill-column 80)", 
            "title": "Navigating Stacktraces"
        }, 
        {
            "location": "/running_tests/", 
            "text": "Running tests\n\n\nYou can run \nclojure.test\n tests pretty quickly in CIDER. Pressing \nC-c C-t\nn\n or \nC-c C-t C-n\n in a source buffer or a REPL buffer will run\nthe tests for the namespace you're currently in. CIDER is smart enough to figure\nout the namespace containing the tests. The inference logic works in a pretty\nsimple manner - if you're in an implementation namespace (e.g. \nsome.ns\n) CIDER\nwill try to find a matching test namespace (by default \nsome.ns-test\n) and run\nthe tests there. On the other hand - if you're in something that looks like a\ntest namespace (e.g. \nsome.ns-test\n), then the command will simply run the tests\nin that namespace. From time to time, however, you might want to suppress the\ntest namespace inference logic (e.g. you have some tests in the implementation\nnamespace that were defined with \nclojure.test/with-test\n)\n- in such cases you should use \nC-u C-c C-t C-n\n, which will simply run\nwhatever tests are present in the currently visited/active namespace.\n\n\nYou can also run all loaded tests with \nC-c C-t l\n or \nC-c C-t\nC-l\n and all tests within a project with \nC-c C-t p\n or \nC-c\nC-t C-p\n (note that this will load \nall\n namespaces in your\nproject). Using \nC-c C-t t\n or \nC-c C-t C-t\n, you can execute\nonly the test a point.\n\n\nAll test commands are available in REPL buffers as well. There you can also use\n\n,\n to invoke some of the testing commands.\n\n\nIn the buffer displaying the test execution results (\n*cider-test-results*\n)\nyou'll have a bit of additional functionality at your disposal.\n\n\n\n\n\n\n\n\nKeyboard shortcut\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ng\n\n\nRun test at point.\n\n\n\n\n\n\nn\n\n\nRun tests for current namespace.\n\n\n\n\n\n\nl\n\n\nRun tests for all loaded namespaces.\n\n\n\n\n\n\np\n\n\nRun tests for all project namespaces. This loads the additional namespaces.\n\n\n\n\n\n\nf\n\n\nRe-run test failures/errors.\n\n\n\n\n\n\nM-p\n\n\nMove point to previous test.\n\n\n\n\n\n\nM-n\n\n\nMove point to next test.\n\n\n\n\n\n\nt\n or \nM-.\n\n\nJump to test definition.\n\n\n\n\n\n\nd\n\n\nDisplay diff of actual vs expected.\n\n\n\n\n\n\ne\n\n\nDisplay test error cause and stacktrace info.\n\n\n\n\n\n\n\n\nCertain aspects of the test execution behavior are configurable:\n\n\n\n\n\n\nIf your tests are not following the \nsome.ns-test\n naming convention you can\ncustomize the variable \ncider-test-infer-test-ns\n. It should be bound to a\nfunction that takes the current namespace and returns the matching test\nnamespace (which may be the same as the current namespace).\n\n\n\n\n\n\nIf your individual tests are not defined by \ndeftest\n or \ndefspec\n, CIDER will\nnot recognize them when searching for a test at point in \ncider-test-run-test\n.\nYou can customize the variable \ncider-test-defining-forms\n to add additional\nforms for CIDER to recognize as individual test definitions.\n\n\n\n\n\n\nIf you want to view the test report regardless of whether the tests have\npassed or failed:\n\n\n\n\n\n\n(setq cider-test-show-report-on-success t)\n\n\n\n\nRunning tests automatically (test-driven development)\n\n\nCIDER provides a minor-mode that automatically runs all tests for a namespace\nwhenever you load a file (with \nC-c C-k\n). You can toggle it\nmanually with \nM-x\n \ncider-auto-test-mode\n, or you can use:\n\n\n(cider-auto-test-mode 1)\n\n\n\n\nThis is completely equivalent to manually typing \nC-c C-t C-n\n every\ntime you load a Clojure buffer. Also, as described above before, CIDER is smart\nenough to figure out the namespace containing the tests.\n\n\nUsing cider-test with alternative test libraries\n\n\nThe \nclojure.test\n machinery is designed to be pluggable. Any test library\ncan implement it if so desired, and therefore leverage \ncider-test\n. For\ninstance, \ntest.check\n does this, and\n\ncider-test\n handles \ndefspec\n just like \ndeftest\n.\n\n\nAs a test framework author, supporting the built-in \nclojure.test\n machinery\n(and hence \ncider-test\n) is pretty straightforward:\n\n\n\n\nAssoc each test fn as \n:test\n metadata on some var. These are what get run.\n\n\nImplement the \nclojure.test/report\n multimethod to capture the test results.\n\n\n\n\nThe \ntest.check\n library is a good example here. It was also designed completely\nindependently of \nclojure.test\n. It just adds compatibility in this\n\nnamespace\n.\n\n\nclojure-expectations\n added\nsupport for \nclojure.test\n in version 2.2 and should also work with CIDER.", 
            "title": "Running Tests"
        }, 
        {
            "location": "/running_tests/#running-tests", 
            "text": "You can run  clojure.test  tests pretty quickly in CIDER. Pressing  C-c C-t\nn  or  C-c C-t C-n  in a source buffer or a REPL buffer will run\nthe tests for the namespace you're currently in. CIDER is smart enough to figure\nout the namespace containing the tests. The inference logic works in a pretty\nsimple manner - if you're in an implementation namespace (e.g.  some.ns ) CIDER\nwill try to find a matching test namespace (by default  some.ns-test ) and run\nthe tests there. On the other hand - if you're in something that looks like a\ntest namespace (e.g.  some.ns-test ), then the command will simply run the tests\nin that namespace. From time to time, however, you might want to suppress the\ntest namespace inference logic (e.g. you have some tests in the implementation\nnamespace that were defined with  clojure.test/with-test )\n- in such cases you should use  C-u C-c C-t C-n , which will simply run\nwhatever tests are present in the currently visited/active namespace.  You can also run all loaded tests with  C-c C-t l  or  C-c C-t\nC-l  and all tests within a project with  C-c C-t p  or  C-c\nC-t C-p  (note that this will load  all  namespaces in your\nproject). Using  C-c C-t t  or  C-c C-t C-t , you can execute\nonly the test a point.  All test commands are available in REPL buffers as well. There you can also use ,  to invoke some of the testing commands.  In the buffer displaying the test execution results ( *cider-test-results* )\nyou'll have a bit of additional functionality at your disposal.     Keyboard shortcut  Description      g  Run test at point.    n  Run tests for current namespace.    l  Run tests for all loaded namespaces.    p  Run tests for all project namespaces. This loads the additional namespaces.    f  Re-run test failures/errors.    M-p  Move point to previous test.    M-n  Move point to next test.    t  or  M-.  Jump to test definition.    d  Display diff of actual vs expected.    e  Display test error cause and stacktrace info.     Certain aspects of the test execution behavior are configurable:    If your tests are not following the  some.ns-test  naming convention you can\ncustomize the variable  cider-test-infer-test-ns . It should be bound to a\nfunction that takes the current namespace and returns the matching test\nnamespace (which may be the same as the current namespace).    If your individual tests are not defined by  deftest  or  defspec , CIDER will\nnot recognize them when searching for a test at point in  cider-test-run-test .\nYou can customize the variable  cider-test-defining-forms  to add additional\nforms for CIDER to recognize as individual test definitions.    If you want to view the test report regardless of whether the tests have\npassed or failed:    (setq cider-test-show-report-on-success t)", 
            "title": "Running tests"
        }, 
        {
            "location": "/running_tests/#running-tests-automatically-test-driven-development", 
            "text": "CIDER provides a minor-mode that automatically runs all tests for a namespace\nwhenever you load a file (with  C-c C-k ). You can toggle it\nmanually with  M-x   cider-auto-test-mode , or you can use:  (cider-auto-test-mode 1)  This is completely equivalent to manually typing  C-c C-t C-n  every\ntime you load a Clojure buffer. Also, as described above before, CIDER is smart\nenough to figure out the namespace containing the tests.", 
            "title": "Running tests automatically (test-driven development)"
        }, 
        {
            "location": "/running_tests/#using-cider-test-with-alternative-test-libraries", 
            "text": "The  clojure.test  machinery is designed to be pluggable. Any test library\ncan implement it if so desired, and therefore leverage  cider-test . For\ninstance,  test.check  does this, and cider-test  handles  defspec  just like  deftest .  As a test framework author, supporting the built-in  clojure.test  machinery\n(and hence  cider-test ) is pretty straightforward:   Assoc each test fn as  :test  metadata on some var. These are what get run.  Implement the  clojure.test/report  multimethod to capture the test results.   The  test.check  library is a good example here. It was also designed completely\nindependently of  clojure.test . It just adds compatibility in this namespace .  clojure-expectations  added\nsupport for  clojure.test  in version 2.2 and should also work with CIDER.", 
            "title": "Using cider-test with alternative test libraries"
        }, 
        {
            "location": "/debugging/", 
            "text": "CIDER ships with a powerful interactive Clojure debugger inspired by Emacs's own\n\nEdebug\n. You're going to love it!\n\n\n\n\nDebugging\n\n\nThe debugger can be invoked in several ways, the simplest one is to type\n\nC-u C-M-x\n. This will take the current top-level form, place as many\nbreakpoints inside it as possible (instrument it), and then evaluate it as\nnormal. Whenever a breakpoint is reached, you'll be shown the value and asked\nfor input (see below). Note that if the current form is a \ndefn\n, it will stay\ninstrumented, so the debugger will be triggered every time the function is\ncalled. To uninstrument \ndefn\n (or similar forms), you just have to evaluate it\nagain as you'd normally do (e.g. with \nC-M-x\n).\n\n\nAnother way to trigger the debugger is by placing breakpoints yourself. Just\nwrite \n#break\n before a form, and the debugger will popup every time that form is\nevaluated. For instance, if you hit \nC-M-x\n on the following, a\nbreakpoint is triggered every time \n(inspector msg)\n is evaluated.\n\n\n(defn eval-msg [{:keys [inspect] :as msg}]\n  (if inspect\n    #break (inspector msg)\n    msg))\n\n\n\n\nInstead of \n#break\n you can also write \n#dbg\n before a form, this will not only\nbreakpoint the form but also everything inside it. In the example above, this\nplaces a breakpoint around \n(inspector msg)\n and another around \nmsg\n. If you've\nbeen paying attention, you may have noticed that the first option (\nC-u\nC-M-x\n) is a quick way of evaluating the current top-level form with \n#dbg\n\nin front.\n\n\nAt any point, you can bring up a list of all currently instrumented \ndef\ns with\nthe command \nM-x\n \ncider-browse-instrumented-defs\n. Protocols and types\ncan be instrumented as well, but they will not be listed by this command.\n\n\nKeys\n\n\ncider-debug\n tries to be consistent with \nEdebug\n, although there are some\ndifferences. It makes available the following bindings while stepping through\ncode.\n\n\n\n\n\n\n\n\nKeyboard shortcut\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nn\n\n\nNext step\n\n\n\n\n\n\ni\n\n\nStep in to a function\n\n\n\n\n\n\no\n\n\nStep out of the current sexp (like \nup-list\n)\n\n\n\n\n\n\nO\n\n\nForce-step out of the current sexp\n\n\n\n\n\n\nh\n\n\nSkip all sexps up to \u201chere\u201d (current position). Move the cursor before doing this.\n\n\n\n\n\n\nH\n\n\nForce-step to \u201chere\u201d\n\n\n\n\n\n\nc\n\n\nContinue without stopping\n\n\n\n\n\n\ne\n\n\nEval code in current context\n\n\n\n\n\n\np\n\n\nInspect a value\n\n\n\n\n\n\nl\n\n\nInspect local variables\n\n\n\n\n\n\nj\n\n\nInject a value into running code\n\n\n\n\n\n\ns\n\n\nShow the current stack\n\n\n\n\n\n\nt\n\n\nTrace. Continue, printing expressions and their values.\n\n\n\n\n\n\nq\n\n\nQuit execution\n\n\n\n\n\n\n\n\nIn addition, all the usual evaluation commands (such as \nC-x C-e\n or\n\nC-c M-:\n) will use the current lexical context (local variables) while\nthe debugger is active.\n\n\nCommand Details\n\n\nHere are some more details about what each of the above commands does.\n\n\nStepping Commands\n\n\nThese commands continue execution until reaching a breakpoint.\n\n\nIn the cider debugger, the term \"breakpoint\" refers to a place where the\ndebugger can halt execution and display the value of an expression. You can set\na single breakpoint with \n#break\n, or set breakpoints throughout a form with\n\n#dbg\n (or by evaluating with \nC-u C-M-x\n). Not every form is wrapped in a\nbreakpoint; the debugger tries to avoid setting breakpoints on expressions that\nwould not be interesting to stop at, such as constants. For example, there would\nnot be much point in stopping execution at a literal number 23 in your code and\nshowing that its value is 23 - you already know that.\n\n\n\n\nnext\n: Steps to the next breakpoint\n\n\nin\n: Steps in to the function about to be called. If the next breakpoint is\n  not around a function call, does the same as \nnext\n. Note that not all\n  functions can be stepped in to - only normal functions stored in vars, for\n  which cider can find the source. You cannot currently step in to multimethods,\n  protocol functions, or functions in clojure.core (although multimethods and\n  protocols can be instrumented manually).\n\n\nout\n: Steps to the next breakpoint that is outside of the current sexp.\n\n\nOut\n: Same as \no\n, but skips breakpoints in other functions. That is, if\n  the code being skipped over contains a call to another instrumented function,\n  the debugger will stop in that function if you step out with \no\n, but not if\n  you step out with \nO\n.\n\n\nhere\n: Place the point somewhere further on in the function being debugged,\n  at the point where you want to stop next. Then press \nh\n, and the debugger\n  will skip all breakpoints up until that spot.\n\n\nHere\n: Same as \nh\n, but skips breakpoints in other functions, as with \nO\n.\n\n\ncontinue\n: Continues without stopping, skipping all breakpoints.\n\n\n\n\nOther Commands\n\n\n\n\neval\n: Prompts for a clojure expression, which can reference local\n  variables that are in scope where the debugger is stopped. Displays the result\n  in an overlay.\n\n\ninspect\n: Like eval, but displays the value in a \ncider-inspector\n buffer.\n\n\nlocals\n: Opens a \ncider-inspector\n buffer displaying all local variables\n  defined in the context where the debugger is stopped.\n\n\ninject\n: Replaces the currently-displayed value with the value of an\n  expression that you type in. Subsequent code will see the new value that you\n  entered.\n\n\nstacktrace\n: Shows the stacktrace of the point where the debugger is\n  stopped.\n\n\ntrace\n: Continues execution, but at each breakpoint, instead of stopping\n  and displaying the value in an overlay, prints the form and its value to the\n  REPL.\n\n\nquit\n: Quits execution immediately. Unlike with \ncontinue\n, the rest of the\n  code in the debugged function is not executed.\n\n\n\n\nConditional Breakpoints\n\n\nBreakpoints can be conditional, such that the debugger will only stop when the\ncondition is true.\n\n\nConditions are specified using \n:break/when\n metadata attached to a form.\n\n\n(dotimes [i 10]\n  #dbg ^{:break/when (= i 7)}\n  (prn i))\n\n\n\n\nEvaluating the above with \nC-M-x\n, the debugger will stop only once, when i\nis 7.\n\n\nYou can also have cider insert the break-condition into your code for you. Place\nthe point where you want the condition to go and evaluate with \nC-u C-u\nC-M-x\n or \nC-u C-u C-c C-c\n.\n\n\nInternal Details\n\n\nThis section explains a bit of the inner workings of the debugger. It is\nintended mostly to help those who are interested in contributing, and doesn't\nteach anything about the debugger's usage.\n\n\nThe CIDER debugger works in several steps:\n\n\n\n\nFirst it walks through the user's code, adding metadata to forms and symbols\n   that identify their position (coordinate) in the code.\n\n\nThen it macroexpands everything to get rid of macros.\n\n\n\n\nThen it walks through the code again, instrumenting it. That involves a few things.\n\n\n\n\nIt understands all existing special forms, and takes care not to instrument\n  where it's not supposed to. For instance, the arglist of a \nfn*\n or the\n  left-side of a \nlet\n-binding.\n\n\nWherever it finds the previously-injected metadata (if that place is valid\n  for instrumentation) it wraps the form/symbol in a macro called\n  \nbreakpoint-if-interesting\n.\n\n\n\n\n\n\n\n\nWhen the resulting code actually gets evaluated by the Clojure compiler, the\n   \nbreakpoint-if-interesting\n macro will be expanded.  This macro decides\n   whether the return value of the form/symbol in question is actually something\n   the user wants to see (see below). If it is, the form/symbol gets wrapped in\n   the \nbreakpoint\n macro, otherwise it's returned as is.\n\n\n\n\nThe \nbreakpoint\n macro takes that coordinate information that was provided in\n   step \n1.\n and sends it over to Emacs (the front-end). It also sends the return\n   value of the form and a prompt of available commands. Emacs then uses this\n   information to show the value of actual code forms and prompt for the next\n   action.\n\n\n\n\nA few example of forms that don't have interesting return values (and so are not\nwrapped in a \nbreakpoint\n):\n\n\n\n\nIn \n(fn [x] (inc x))\n the return value is a function object and carries no\n  information. Note that this is not the same as the return value when you\n  \ncall\n this function (which \nis\n interesting). Also, even those this form\n  is not wrapped in a breakpoint, the forms inside it \nare\n (\n(inc x)\n and\n  \nx\n).\n\n\nSimilarly, in a form like \n(map inc (range 10))\n, the symbol \ninc\n points to a\n  function in \nclojure.core\n. That's also irrelevant (unless it's being shadowed\n  by a local, but the debugger can identify that).", 
            "title": "Debugging"
        }, 
        {
            "location": "/debugging/#debugging", 
            "text": "The debugger can be invoked in several ways, the simplest one is to type C-u C-M-x . This will take the current top-level form, place as many\nbreakpoints inside it as possible (instrument it), and then evaluate it as\nnormal. Whenever a breakpoint is reached, you'll be shown the value and asked\nfor input (see below). Note that if the current form is a  defn , it will stay\ninstrumented, so the debugger will be triggered every time the function is\ncalled. To uninstrument  defn  (or similar forms), you just have to evaluate it\nagain as you'd normally do (e.g. with  C-M-x ).  Another way to trigger the debugger is by placing breakpoints yourself. Just\nwrite  #break  before a form, and the debugger will popup every time that form is\nevaluated. For instance, if you hit  C-M-x  on the following, a\nbreakpoint is triggered every time  (inspector msg)  is evaluated.  (defn eval-msg [{:keys [inspect] :as msg}]\n  (if inspect\n    #break (inspector msg)\n    msg))  Instead of  #break  you can also write  #dbg  before a form, this will not only\nbreakpoint the form but also everything inside it. In the example above, this\nplaces a breakpoint around  (inspector msg)  and another around  msg . If you've\nbeen paying attention, you may have noticed that the first option ( C-u\nC-M-x ) is a quick way of evaluating the current top-level form with  #dbg \nin front.  At any point, you can bring up a list of all currently instrumented  def s with\nthe command  M-x   cider-browse-instrumented-defs . Protocols and types\ncan be instrumented as well, but they will not be listed by this command.", 
            "title": "Debugging"
        }, 
        {
            "location": "/debugging/#keys", 
            "text": "cider-debug  tries to be consistent with  Edebug , although there are some\ndifferences. It makes available the following bindings while stepping through\ncode.     Keyboard shortcut  Description      n  Next step    i  Step in to a function    o  Step out of the current sexp (like  up-list )    O  Force-step out of the current sexp    h  Skip all sexps up to \u201chere\u201d (current position). Move the cursor before doing this.    H  Force-step to \u201chere\u201d    c  Continue without stopping    e  Eval code in current context    p  Inspect a value    l  Inspect local variables    j  Inject a value into running code    s  Show the current stack    t  Trace. Continue, printing expressions and their values.    q  Quit execution     In addition, all the usual evaluation commands (such as  C-x C-e  or C-c M-: ) will use the current lexical context (local variables) while\nthe debugger is active.", 
            "title": "Keys"
        }, 
        {
            "location": "/debugging/#command-details", 
            "text": "Here are some more details about what each of the above commands does.", 
            "title": "Command Details"
        }, 
        {
            "location": "/debugging/#stepping-commands", 
            "text": "These commands continue execution until reaching a breakpoint.  In the cider debugger, the term \"breakpoint\" refers to a place where the\ndebugger can halt execution and display the value of an expression. You can set\na single breakpoint with  #break , or set breakpoints throughout a form with #dbg  (or by evaluating with  C-u C-M-x ). Not every form is wrapped in a\nbreakpoint; the debugger tries to avoid setting breakpoints on expressions that\nwould not be interesting to stop at, such as constants. For example, there would\nnot be much point in stopping execution at a literal number 23 in your code and\nshowing that its value is 23 - you already know that.   next : Steps to the next breakpoint  in : Steps in to the function about to be called. If the next breakpoint is\n  not around a function call, does the same as  next . Note that not all\n  functions can be stepped in to - only normal functions stored in vars, for\n  which cider can find the source. You cannot currently step in to multimethods,\n  protocol functions, or functions in clojure.core (although multimethods and\n  protocols can be instrumented manually).  out : Steps to the next breakpoint that is outside of the current sexp.  Out : Same as  o , but skips breakpoints in other functions. That is, if\n  the code being skipped over contains a call to another instrumented function,\n  the debugger will stop in that function if you step out with  o , but not if\n  you step out with  O .  here : Place the point somewhere further on in the function being debugged,\n  at the point where you want to stop next. Then press  h , and the debugger\n  will skip all breakpoints up until that spot.  Here : Same as  h , but skips breakpoints in other functions, as with  O .  continue : Continues without stopping, skipping all breakpoints.", 
            "title": "Stepping Commands"
        }, 
        {
            "location": "/debugging/#other-commands", 
            "text": "eval : Prompts for a clojure expression, which can reference local\n  variables that are in scope where the debugger is stopped. Displays the result\n  in an overlay.  inspect : Like eval, but displays the value in a  cider-inspector  buffer.  locals : Opens a  cider-inspector  buffer displaying all local variables\n  defined in the context where the debugger is stopped.  inject : Replaces the currently-displayed value with the value of an\n  expression that you type in. Subsequent code will see the new value that you\n  entered.  stacktrace : Shows the stacktrace of the point where the debugger is\n  stopped.  trace : Continues execution, but at each breakpoint, instead of stopping\n  and displaying the value in an overlay, prints the form and its value to the\n  REPL.  quit : Quits execution immediately. Unlike with  continue , the rest of the\n  code in the debugged function is not executed.", 
            "title": "Other Commands"
        }, 
        {
            "location": "/debugging/#conditional-breakpoints", 
            "text": "Breakpoints can be conditional, such that the debugger will only stop when the\ncondition is true.  Conditions are specified using  :break/when  metadata attached to a form.  (dotimes [i 10]\n  #dbg ^{:break/when (= i 7)}\n  (prn i))  Evaluating the above with  C-M-x , the debugger will stop only once, when i\nis 7.  You can also have cider insert the break-condition into your code for you. Place\nthe point where you want the condition to go and evaluate with  C-u C-u\nC-M-x  or  C-u C-u C-c C-c .", 
            "title": "Conditional Breakpoints"
        }, 
        {
            "location": "/debugging/#internal-details", 
            "text": "This section explains a bit of the inner workings of the debugger. It is\nintended mostly to help those who are interested in contributing, and doesn't\nteach anything about the debugger's usage.  The CIDER debugger works in several steps:   First it walks through the user's code, adding metadata to forms and symbols\n   that identify their position (coordinate) in the code.  Then it macroexpands everything to get rid of macros.   Then it walks through the code again, instrumenting it. That involves a few things.   It understands all existing special forms, and takes care not to instrument\n  where it's not supposed to. For instance, the arglist of a  fn*  or the\n  left-side of a  let -binding.  Wherever it finds the previously-injected metadata (if that place is valid\n  for instrumentation) it wraps the form/symbol in a macro called\n   breakpoint-if-interesting .     When the resulting code actually gets evaluated by the Clojure compiler, the\n    breakpoint-if-interesting  macro will be expanded.  This macro decides\n   whether the return value of the form/symbol in question is actually something\n   the user wants to see (see below). If it is, the form/symbol gets wrapped in\n   the  breakpoint  macro, otherwise it's returned as is.   The  breakpoint  macro takes that coordinate information that was provided in\n   step  1.  and sends it over to Emacs (the front-end). It also sends the return\n   value of the form and a prompt of available commands. Emacs then uses this\n   information to show the value of actual code forms and prompt for the next\n   action.   A few example of forms that don't have interesting return values (and so are not\nwrapped in a  breakpoint ):   In  (fn [x] (inc x))  the return value is a function object and carries no\n  information. Note that this is not the same as the return value when you\n   call  this function (which  is  interesting). Also, even those this form\n  is not wrapped in a breakpoint, the forms inside it  are  ( (inc x)  and\n   x ).  Similarly, in a form like  (map inc (range 10)) , the symbol  inc  points to a\n  function in  clojure.core . That's also irrelevant (unless it's being shadowed\n  by a local, but the debugger can identify that).", 
            "title": "Internal Details"
        }, 
        {
            "location": "/managing_connections/", 
            "text": "Overview\n\n\nYou can connect to multiple nREPL servers using \nM-x\n \ncider-jack-in\n\n(or \ncider-connect\n) multiple times.  To close the current nREPL connection, use\n\nC-c C-q\n (\ncider-quit\n). You can close all connections with\n\nC-u C-c C-q\n.\n\n\nCIDER maintains a list of nREPL connections and a single 'default'\nconnection. When you execute CIDER commands in a Clojure editing buffer such as\nto compile a namespace, these commands are executed against a specific\nconnection. This is controlled by the variable \ncider-request-dispatch\n - when\nit's set to \n'dynamic\n (the default), CIDER will try to infer which connection\nto use from the current project and currently visited file; when \n'static\n\ndispatch is used all requests will always be routed to the default connection\n(this was the default behavior in CIDER before 0.10).\n\n\nThere's a handy command called \ncider-toggle-request-dispatch\n. You can use it\nto quickly switch between dynamic and static request dispatch. A common use-case\nfor it would be to force temporary all evaluation commands to be using a\nparticular (the default) connection.\n\n\nYou can display the current nREPL connection using \nC-c M-d\n\nand rotate the default connection using \nC-c M-r\n. Another\noption for setting the default connection is to execute the command\n\nM-x\n \ncider-make-connection-default\n in the appropriate\nREPL buffer.\n\n\nConnection browser\n\n\nYou can obtain a list of all active connections using \nM-x\n\n\ncider-connection-browser\n. This buffer provides a few extra keybindings:\n\n\n\n\n\n\n\n\nCommand\n\n\nKeyboard shortcut\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncider-connections-make-default\n\n\nd\n\n\nMake connection at point default.\n\n\n\n\n\n\ncider-connections-close-connection\n\n\nk\n\n\nClose connection at point.\n\n\n\n\n\n\ncider-connection-browser\n\n\ng\n\n\nRefresh connection browser.\n\n\n\n\n\n\ncider-connections-goto-connection\n\n\nRET\n\n\nVisit connection buffer.\n\n\n\n\n\n\ncider-popup-buffer-quit-function\n\n\nq\n\n\nClose window.\n\n\n\n\n\n\n\n\nSwitch to connection buffer\n\n\nThe REPL buffers double as connection buffers.\n\n\nTo switch to the relevant REPL buffer based on the Clojure namespace\nin the current Clojure buffer, use: \nC-c C-z\n. You can then\nuse the same key combination to switch back to the Clojure buffer you\ncame from.\n\n\nThe single prefix \nC-u C-c C-z\n, will switch you to the\nrelevant REPL buffer and set the namespace in that buffer based on\nnamespace in the current Clojure buffer.\n\n\nRenaming connections\n\n\nTo change the designation used for CIDER buffers use \nM-x\n\n\ncider-change-buffers-designation\n. This changes the CIDER REPL\nbuffer, nREPL connection buffer and nREPL server buffer. For example\nusing \ncider-change-buffers-designation\n with the string \"foo\" would\nchange \n*cider-repl localhost*\n to \n*cider-repl foo*\n.", 
            "title": "Managing Connections"
        }, 
        {
            "location": "/managing_connections/#overview", 
            "text": "You can connect to multiple nREPL servers using  M-x   cider-jack-in \n(or  cider-connect ) multiple times.  To close the current nREPL connection, use C-c C-q  ( cider-quit ). You can close all connections with C-u C-c C-q .  CIDER maintains a list of nREPL connections and a single 'default'\nconnection. When you execute CIDER commands in a Clojure editing buffer such as\nto compile a namespace, these commands are executed against a specific\nconnection. This is controlled by the variable  cider-request-dispatch  - when\nit's set to  'dynamic  (the default), CIDER will try to infer which connection\nto use from the current project and currently visited file; when  'static \ndispatch is used all requests will always be routed to the default connection\n(this was the default behavior in CIDER before 0.10).  There's a handy command called  cider-toggle-request-dispatch . You can use it\nto quickly switch between dynamic and static request dispatch. A common use-case\nfor it would be to force temporary all evaluation commands to be using a\nparticular (the default) connection.  You can display the current nREPL connection using  C-c M-d \nand rotate the default connection using  C-c M-r . Another\noption for setting the default connection is to execute the command M-x   cider-make-connection-default  in the appropriate\nREPL buffer.", 
            "title": "Overview"
        }, 
        {
            "location": "/managing_connections/#connection-browser", 
            "text": "You can obtain a list of all active connections using  M-x  cider-connection-browser . This buffer provides a few extra keybindings:     Command  Keyboard shortcut  Description      cider-connections-make-default  d  Make connection at point default.    cider-connections-close-connection  k  Close connection at point.    cider-connection-browser  g  Refresh connection browser.    cider-connections-goto-connection  RET  Visit connection buffer.    cider-popup-buffer-quit-function  q  Close window.", 
            "title": "Connection browser"
        }, 
        {
            "location": "/managing_connections/#switch-to-connection-buffer", 
            "text": "The REPL buffers double as connection buffers.  To switch to the relevant REPL buffer based on the Clojure namespace\nin the current Clojure buffer, use:  C-c C-z . You can then\nuse the same key combination to switch back to the Clojure buffer you\ncame from.  The single prefix  C-u C-c C-z , will switch you to the\nrelevant REPL buffer and set the namespace in that buffer based on\nnamespace in the current Clojure buffer.", 
            "title": "Switch to connection buffer"
        }, 
        {
            "location": "/managing_connections/#renaming-connections", 
            "text": "To change the designation used for CIDER buffers use  M-x  cider-change-buffers-designation . This changes the CIDER REPL\nbuffer, nREPL connection buffer and nREPL server buffer. For example\nusing  cider-change-buffers-designation  with the string \"foo\" would\nchange  *cider-repl localhost*  to  *cider-repl foo* .", 
            "title": "Renaming connections"
        }, 
        {
            "location": "/miscellaneous_features/", 
            "text": "CIDER packs a ton of extra functionality, besides basic Clojure code\nevaluation. Much of the functionality is centered around additional major modes,\nwhich provide you with convenient ways to get something done or inspect\nsomething.\n\n\nEvaluating Clojure code in the minibuffer\n\n\nYou can evaluate Clojure code in the minibuffer from pretty much everywhere by\nusing \nM-x\n \ncider-read-and-eval\n (bound in \ncider-mode\n buffers to\n\nC-c M-:\n).  \nTAB\n completion will work in the minibuffer,\njust as in a REPL/source buffer.\n\n\nPressing \nC-c C-v .\n in a Clojure buffer will insert the defun\nat point into the minibuffer for evaluation. This way you can pass arguments\nto the function and evaluate it and see the result in the minibuffer.\n\n\nYou can also enable \neldoc-mode\n in the minibuffer by adding the following to your\nconfig:\n\n\n(add-hook 'eval-expression-minibuffer-setup-hook #'eldoc-mode)\n\n\n\n\nYou can also enable \nparedit\n or \nsmartparens\n for minibuffer evaluations:\n\n\n(add-hook 'eval-expression-minibuffer-setup-hook #'paredit-mode)\n\n\n\n\nUsing a scratchpad\n\n\nCIDER provides a simple way to create a Clojure scratchpad via the\n\nM-x\n \ncider-scratch\n command. It provides a great way to\nplay around with some code, without having to create source files\nor pollute the REPL buffer.\n\n\nIn many ways the CIDER scratchpad is similar to Emacs's own \n*scratch*\n buffer.\n\n\nMacroexpansion\n\n\nPressing \nC-c C-m\n after some form in a source buffer or the REPL will\nresult in a new buffer, showing the macroexpansion of the form in\nquestion. You'll have access to additional keybindings in the macroexpansion\nbuffer (which is internally using \ncider-macroexpansion-mode\n):\n\n\n\n\n\n\n\n\nKeyboard shortcut\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nm\n\n\nInvoke \nmacroexpand-1\n on the form at point and replace the original form with its expansion.  If invoked with a prefix argument, \nmacroexpand\n is used instead of \nmacroexpand-1\n.\n\n\n\n\n\n\na\n\n\nInvoke \nclojure.walk/macroexpand-all\n on the form at point and replace the original form with its expansion.\n\n\n\n\n\n\ng\n\n\nThe prior macroexpansion is performed again and the current contents of the macroexpansion buffer are replaced with the new expansion.\n\n\n\n\n\n\nC-/\n \n \nu\n\n\nUndo the last inplace expansion performed in the macroexpansion buffer.\n\n\n\n\n\n\n\n\nValue inspection\n\n\nPressing \nC-c M-i\n after some form in a source buffer or the REPL will\nresult in a new buffer, showing the structure of the result of the form in question.\nYou can also use \nC-u C-c M-i\n to inspect the result of the current top-level\nform and \nC-u C-u C-c M-i\n to read an expression from the minibuffer and\ninspect its result.\n\n\nYou'll have access to additional keybindings in the inspector buffer (which is\ninternally using \ncider-inspector-mode\n):\n\n\n\n\n\n\n\n\nKeyboard shortcut\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nTab\n or \nShift-Tab\n\n\nNavigate inspectable sub-objects\n\n\n\n\n\n\nReturn\n\n\nInspect sub-objects\n\n\n\n\n\n\nl\n\n\nPop to the parent object\n\n\n\n\n\n\ng\n\n\nRefresh the inspector (e.g. if viewing an atom/ref/agent)\n\n\n\n\n\n\nSPC\n\n\nJump to next page in paginated view\n\n\n\n\n\n\nM-SPC\n\n\nJump to previous page in paginated view\n\n\n\n\n\n\ns\n\n\nSet a new page size in paginated view\n\n\n\n\n\n\n\n\nEnlighten (display local values)\n\n\nThis feature displays the value of locals in realtime, as your code is being\nexecuted. This is somewhat akin to one of the features of the Light Table\neditor.\n\n\n\n\nTo turn it on, issue \nM-x\n \ncider-enlighten-mode\n.\n\n\nTo use it, evaluate your functions one at a time (e.g., use \nC-M-x\n or\n\nC-x  C-e\n, because \nC-c C-k\n won't work).\n\n\n\n\nThat's it! Once your code executes, the regular old buffer on the left will turn\ninto the brilliant show of lights on the right.\n\n\n\n  \n\n  \n\n\n\n\n\nTo stop displaying the locals you'll have to disable \ncider-enlighten-mode\n\nand reevaluate the definitions you had instrumented previously.\n\n\nYou can also trigger this on specific functions (without having to turn on the\nminor mode) by writing \n#light\n before the \n(def\n and reevaluating it.\n\n\nCode reloading\n\n\ncider-refresh\n wraps\n\nclojure.tools.namespace\n, and as\nsuch the same\n\nbenefits\n\nand\n\ncaveats\n\nregarding writing reloadable code also apply.\n\n\nCalling \ncider-refresh\n will cause all modified Clojure files on the classpath\nto be reloaded. You can also provide a single prefix argument to reload all\nClojure files on the classpath unconditionally, or a double prefix argument to\nfirst clear the state of the namespace tracker before reloading.\n\n\nThe above three operations are analogous to\n\nclojure.tools.namespace.repl/refresh\n,\n\nclojure.tools.namespace.repl/refresh-all\n\nand\n\nclojure.tools.namespace.repl/clear\n\n(followed by a normal refresh), respectively.\n\n\n\n\nYou can define Clojure functions to be called before reloading, and after a\n  successful reload, when using \ncider-refresh\n:\n\n\n\n\n(setq cider-refresh-before-fn \nuser/stop-system!\n\n      cider-refresh-after-fn \nuser/start-system!\n)\n\n\n\n\n\n\n\n\nThese must be set to the namespace-qualified names of vars bound to functions\n  of no arguments. The functions must be synchronous (blocking), and are\n  expected to be side-effecting - they will always be executed serially, without\n  retries.\n\n\n\n\n\n\nBy default, messages regarding the status of the in-progress reload will be\n  displayed in the echo area after you call \ncider-refresh\n. The same\n  information will also be recorded in the \n*cider-refresh-log*\n buffer, along\n  with anything printed to \n*out*\n or \n*err*\n by \ncider-refresh-before-fn\n and\n  \ncider-refresh-start-fn\n.\n\n\n\n\n\n\nYou can make the \n*cider-refresh-log*\n buffer display automatically after you\n  call \ncider-refresh\n by setting the \ncider-refresh-show-log-buffer\n variable\n  to a non-nil value (this will also prevent any related messages from also\n  being displayed in the echo area):\n\n\n\n\n\n\n(setq cider-refresh-show-log-buffer t)\n\n\n\n\n\n\nBy default, all modified Clojure buffers are prompted to be saved. This\n  behaviour can be customized using \ncider-save-files-on-cider-refresh\n.\n\n\n\n\nTracing function execution\n\n\nYou can trace the results produced by functions using \nC-c M-t v\n.  The\ncommand will prompt you for the name of the function you want to trace.\nEvaluating the command again for the same function will result in the function\nbeing untraced.\n\n\n\n\nYou can also use \nC-c M-t n\n to toggle tracing on and off for an entire\nnamespace.\n\n\nClasspath browser\n\n\nYou can easily browse the items on your classpath with the command\n\nM-x\n \ncider-classpath\n.\n\n\nHere you can see it in action:\n\n\n\n\nPress \nRET\n on a classpath entry to navigate into it.\n\n\nNamespace browser\n\n\nYou can browse the contents of any loaded namespace with the command\n\nM-x\n \ncider-browse-ns\n.  The command will prompt you for the namespace\nto browse.\n\n\n\n\nYou can also browse all available namespaces with \nM-x\n\n\ncider-browse-ns-all\n.\n\n\nThere are a bunch of useful keybindings that are defined in browser buffers.\n\n\n\n\n\n\n\n\nKeyboard shortcut\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nd\n\n\nDisplay documentation for item at point.\n\n\n\n\n\n\nRET\n\n\nBrowse ns or display documentation for item at point.\n\n\n\n\n\n\ns\n\n\nGo to definition for item at point.\n\n\n\n\n\n\n^\n\n\nBrowse all namespaces.\n\n\n\n\n\n\nn\n\n\nGo to next line.\n\n\n\n\n\n\np\n\n\nGo to previous line.\n\n\n\n\n\n\n\n\nSpec browser\n\n\nIf you are using  Clojure 1.9.0-alpha16 or newer you can browse the Clojure specs registry.\n\n\nIf you know what you are looking for, you can type \nM-x\n \ncider-browse-spec\n.\nIt will prompt you for a spec name to browse to, hit \nRET\n and you will find yourself\nat the spec browser.\n\n\n\n\nYou can also type the command \nM-x\n \ncider-browse-spec-all\n. This command will prompt you for \na regex you can use to filter out the specs you are interested in, and will also take you to the spec browser. \n\n\n\n\nOnce in the browser you can use your mouse or the keybindings below to navigate deeper into sub specs.\n\n\n\n\n\n\n\n\nKeyboard shortcut\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nRET\n\n\nBrowse the spec at point.\n\n\n\n\n\n\n^\n\n\nGo up in the navigation stack.\n\n\n\n\n\n\nn\n\n\nGo to next spec.\n\n\n\n\n\n\np\n\n\nGo to previous spec.\n\n\n\n\n\n\ne\n\n\nGenerate an example for the current browser spec.\n\n\n\n\n\n\n\n\nIf your project contains a version of \norg.clojure/test.check\n, you can type \ne\n when browsing \na spec to generate and print an example of it.\n\n\n\n\nDocumentation buffers include \"See Also\" references\n\n\nYou can add references to other vars by including their names in \n`\n in the docstring.\nIf the var is in another namespace, then you'll have to include the full\nnamespace qualified name in the docstring. If you want to use some other delimiter instead\nof the backticks, you'll have to update the value of \ncider-doc-xref-regexp\n to match that.\nThe first group of the regexp should always match the var name.\n\n\nAs an example, if you want to want to use the delimiter style used by\n\nCodox\n (\n[[...]]\n)  the regexp would be;\n\n\n(setq cider-doc-xref-regexp \n\\\\[\\\\[\\\\(.*?\\\\)\\\\]\\\\]\n)\n\n\n\n\n\n\nExample function with a docstring containing references:\n\n\n(defn test-fn\n  \nTest function.\n  Also see: `clojure.core/map`, `clojure.core/reduce`, `defn`.\n  You can reference variables like `thor`, `kubaru.data.zookeeper/yoda`.\n  Also works with references to java interop forms, `java.lang.String/.length`.\n\n  []\n  (+ 1 1))", 
            "title": "Miscellaneous Features"
        }, 
        {
            "location": "/miscellaneous_features/#evaluating-clojure-code-in-the-minibuffer", 
            "text": "You can evaluate Clojure code in the minibuffer from pretty much everywhere by\nusing  M-x   cider-read-and-eval  (bound in  cider-mode  buffers to C-c M-: ).   TAB  completion will work in the minibuffer,\njust as in a REPL/source buffer.  Pressing  C-c C-v .  in a Clojure buffer will insert the defun\nat point into the minibuffer for evaluation. This way you can pass arguments\nto the function and evaluate it and see the result in the minibuffer.  You can also enable  eldoc-mode  in the minibuffer by adding the following to your\nconfig:  (add-hook 'eval-expression-minibuffer-setup-hook #'eldoc-mode)  You can also enable  paredit  or  smartparens  for minibuffer evaluations:  (add-hook 'eval-expression-minibuffer-setup-hook #'paredit-mode)", 
            "title": "Evaluating Clojure code in the minibuffer"
        }, 
        {
            "location": "/miscellaneous_features/#using-a-scratchpad", 
            "text": "CIDER provides a simple way to create a Clojure scratchpad via the M-x   cider-scratch  command. It provides a great way to\nplay around with some code, without having to create source files\nor pollute the REPL buffer.  In many ways the CIDER scratchpad is similar to Emacs's own  *scratch*  buffer.", 
            "title": "Using a scratchpad"
        }, 
        {
            "location": "/miscellaneous_features/#macroexpansion", 
            "text": "Pressing  C-c C-m  after some form in a source buffer or the REPL will\nresult in a new buffer, showing the macroexpansion of the form in\nquestion. You'll have access to additional keybindings in the macroexpansion\nbuffer (which is internally using  cider-macroexpansion-mode ):     Keyboard shortcut  Description      m  Invoke  macroexpand-1  on the form at point and replace the original form with its expansion.  If invoked with a prefix argument,  macroexpand  is used instead of  macroexpand-1 .    a  Invoke  clojure.walk/macroexpand-all  on the form at point and replace the original form with its expansion.    g  The prior macroexpansion is performed again and the current contents of the macroexpansion buffer are replaced with the new expansion.    C-/     u  Undo the last inplace expansion performed in the macroexpansion buffer.", 
            "title": "Macroexpansion"
        }, 
        {
            "location": "/miscellaneous_features/#value-inspection", 
            "text": "Pressing  C-c M-i  after some form in a source buffer or the REPL will\nresult in a new buffer, showing the structure of the result of the form in question.\nYou can also use  C-u C-c M-i  to inspect the result of the current top-level\nform and  C-u C-u C-c M-i  to read an expression from the minibuffer and\ninspect its result.  You'll have access to additional keybindings in the inspector buffer (which is\ninternally using  cider-inspector-mode ):     Keyboard shortcut  Description      Tab  or  Shift-Tab  Navigate inspectable sub-objects    Return  Inspect sub-objects    l  Pop to the parent object    g  Refresh the inspector (e.g. if viewing an atom/ref/agent)    SPC  Jump to next page in paginated view    M-SPC  Jump to previous page in paginated view    s  Set a new page size in paginated view", 
            "title": "Value inspection"
        }, 
        {
            "location": "/miscellaneous_features/#enlighten-display-local-values", 
            "text": "This feature displays the value of locals in realtime, as your code is being\nexecuted. This is somewhat akin to one of the features of the Light Table\neditor.   To turn it on, issue  M-x   cider-enlighten-mode .  To use it, evaluate your functions one at a time (e.g., use  C-M-x  or C-x  C-e , because  C-c C-k  won't work).   That's it! Once your code executes, the regular old buffer on the left will turn\ninto the brilliant show of lights on the right.  \n   \n     To stop displaying the locals you'll have to disable  cider-enlighten-mode \nand reevaluate the definitions you had instrumented previously.  You can also trigger this on specific functions (without having to turn on the\nminor mode) by writing  #light  before the  (def  and reevaluating it.", 
            "title": "Enlighten (display local values)"
        }, 
        {
            "location": "/miscellaneous_features/#code-reloading", 
            "text": "cider-refresh  wraps clojure.tools.namespace , and as\nsuch the same benefits \nand caveats \nregarding writing reloadable code also apply.  Calling  cider-refresh  will cause all modified Clojure files on the classpath\nto be reloaded. You can also provide a single prefix argument to reload all\nClojure files on the classpath unconditionally, or a double prefix argument to\nfirst clear the state of the namespace tracker before reloading.  The above three operations are analogous to clojure.tools.namespace.repl/refresh , clojure.tools.namespace.repl/refresh-all \nand clojure.tools.namespace.repl/clear \n(followed by a normal refresh), respectively.   You can define Clojure functions to be called before reloading, and after a\n  successful reload, when using  cider-refresh :   (setq cider-refresh-before-fn  user/stop-system! \n      cider-refresh-after-fn  user/start-system! )    These must be set to the namespace-qualified names of vars bound to functions\n  of no arguments. The functions must be synchronous (blocking), and are\n  expected to be side-effecting - they will always be executed serially, without\n  retries.    By default, messages regarding the status of the in-progress reload will be\n  displayed in the echo area after you call  cider-refresh . The same\n  information will also be recorded in the  *cider-refresh-log*  buffer, along\n  with anything printed to  *out*  or  *err*  by  cider-refresh-before-fn  and\n   cider-refresh-start-fn .    You can make the  *cider-refresh-log*  buffer display automatically after you\n  call  cider-refresh  by setting the  cider-refresh-show-log-buffer  variable\n  to a non-nil value (this will also prevent any related messages from also\n  being displayed in the echo area):    (setq cider-refresh-show-log-buffer t)   By default, all modified Clojure buffers are prompted to be saved. This\n  behaviour can be customized using  cider-save-files-on-cider-refresh .", 
            "title": "Code reloading"
        }, 
        {
            "location": "/miscellaneous_features/#tracing-function-execution", 
            "text": "You can trace the results produced by functions using  C-c M-t v .  The\ncommand will prompt you for the name of the function you want to trace.\nEvaluating the command again for the same function will result in the function\nbeing untraced.   You can also use  C-c M-t n  to toggle tracing on and off for an entire\nnamespace.", 
            "title": "Tracing function execution"
        }, 
        {
            "location": "/miscellaneous_features/#classpath-browser", 
            "text": "You can easily browse the items on your classpath with the command M-x   cider-classpath .  Here you can see it in action:   Press  RET  on a classpath entry to navigate into it.", 
            "title": "Classpath browser"
        }, 
        {
            "location": "/miscellaneous_features/#namespace-browser", 
            "text": "You can browse the contents of any loaded namespace with the command M-x   cider-browse-ns .  The command will prompt you for the namespace\nto browse.   You can also browse all available namespaces with  M-x  cider-browse-ns-all .  There are a bunch of useful keybindings that are defined in browser buffers.     Keyboard shortcut  Description      d  Display documentation for item at point.    RET  Browse ns or display documentation for item at point.    s  Go to definition for item at point.    ^  Browse all namespaces.    n  Go to next line.    p  Go to previous line.", 
            "title": "Namespace browser"
        }, 
        {
            "location": "/miscellaneous_features/#spec-browser", 
            "text": "If you are using  Clojure 1.9.0-alpha16 or newer you can browse the Clojure specs registry.  If you know what you are looking for, you can type  M-x   cider-browse-spec .\nIt will prompt you for a spec name to browse to, hit  RET  and you will find yourself\nat the spec browser.   You can also type the command  M-x   cider-browse-spec-all . This command will prompt you for \na regex you can use to filter out the specs you are interested in, and will also take you to the spec browser.    Once in the browser you can use your mouse or the keybindings below to navigate deeper into sub specs.     Keyboard shortcut  Description      RET  Browse the spec at point.    ^  Go up in the navigation stack.    n  Go to next spec.    p  Go to previous spec.    e  Generate an example for the current browser spec.     If your project contains a version of  org.clojure/test.check , you can type  e  when browsing \na spec to generate and print an example of it.", 
            "title": "Spec browser"
        }, 
        {
            "location": "/miscellaneous_features/#documentation-buffers-include-see-also-references", 
            "text": "You can add references to other vars by including their names in  `  in the docstring.\nIf the var is in another namespace, then you'll have to include the full\nnamespace qualified name in the docstring. If you want to use some other delimiter instead\nof the backticks, you'll have to update the value of  cider-doc-xref-regexp  to match that.\nThe first group of the regexp should always match the var name.  As an example, if you want to want to use the delimiter style used by Codox  ( [[...]] )  the regexp would be;  (setq cider-doc-xref-regexp  \\\\[\\\\[\\\\(.*?\\\\)\\\\]\\\\] )   Example function with a docstring containing references:  (defn test-fn\n   Test function.\n  Also see: `clojure.core/map`, `clojure.core/reduce`, `defn`.\n  You can reference variables like `thor`, `kubaru.data.zookeeper/yoda`.\n  Also works with references to java interop forms, `java.lang.String/.length`. \n  []\n  (+ 1 1))", 
            "title": "Documentation buffers include \"See Also\" references"
        }, 
        {
            "location": "/configuration/", 
            "text": "In the spirit of Emacs almost every aspect of CIDER's behaviour\nis configurable. We've tried to come up with some reasonable\ndefaults, but we've also tried to account for different people's\npreferences, so everyone could make CIDER as comfortable as\npossible for them.\n\n\nYou can see every single customizable configuration option with the command\n\nM-x customize-group RET cider\n.\n\n\nYou can certainly use CIDER without configuring it any further,\nbut here are some ways other folks are adjusting their CIDER\nexperience.\n\n\nBasic configuration\n\n\nAuto-enabling cider-mode in clojure-mode buffers\n\n\nBy default CIDER will enable \ncider-mode\n in all \nclojure-mode\n buffers when the\nfirst CIDER connection is established. It will also add a \nclojure-mode\n hook to\nenable it on newly created \nclojure-mode\n buffers. The configuration snippet\nbellow allows you to override this (somewhat non-standard) behavior.\n\n\n;; Suppress auto-enabling of `cider-mode` in `clojure-mode` buffers, when starting CIDER\n(setq cider-auto-mode nil)\n\n\n\n\nPrompt for confirmation of the symbol at point\n\n\nBy default, interactive commands that require a symbol (e.g. \ncider-doc\n) will\nprompt for the symbol, with the prompt defaulting to the symbol at point. You\ncan set \ncider-prompt-for-symbol\n to \nnil\n to instead try the command with the\nsymbol at point first, and only prompt if that fails (this used to be the\ndefault behavior in older CIDER releases).\n\n\n(setq cider-prompt-for-symbol nil)\n\n\n\n\nLog communication with the nREPL server\n\n\n(setq nrepl-log-messages t)\n\n\n\n\nBasically, this will result in the creation of buffers like \n*nrepl-messages\nconn-name*\n. The communication log is invaluable for debugging CIDER issues, so\nyou're generally advised to enable logging when you need to debug something\nnREPL related.\n\n\nHide special nREPL buffers\n\n\nYou can hide the \n*nrepl-connection*\n and \n*nrepl-server*\n buffers\nfrom appearing in some buffer switching commands like\n\nswitch-to-buffer\n(\nC-x b\n) like this:\n\n\n(setq nrepl-hide-special-buffers t)\n\n\n\n\nWhen using \nswitch-to-buffer\n, pressing \nSPC\n after the command will\nmake the hidden buffers visible. They'll always be visible in\n\nlist-buffers\n (\nC-x C-b\n).\n\n\nPrefer local resources over remote ones\n\n\nTo prefer local resources to remote (tramp) ones when both are available:\n\n\n(setq cider-prefer-local-resources t)\n\n\n\n\nAuto-save Clojure buffers on load\n\n\nNormally CIDER would prompt you to save a modified Clojure buffer on \nC-c C-k\n (\ncider-load-buffer\n).\nYou can change this behaviour by adjusting \ncider-save-file-on-load\n:\n\n\n;; Don't prompt and don't save\n(setq cider-save-file-on-load nil)\n;; Just save without prompting\n(setq cider-save-file-on-load t)\n\n\n\n\nChanging the result prefix for interactive evaluation\n\n\nChange the result prefix for interactive evaluation (by default it's \n=\n):\n\n\n(setq cider-eval-result-prefix \n;; =\n \n)\n\n\n\n\nTo remove the prefix altogether just set it to an empty string(\n\"\"\n).\n\n\nUse a local copy of the JDK API documentation\n\n\nIf you are targeting the JVM and prefer a local copy of the JDK API\ndocumentation over Oracle's official copy (e.g., for\n\nJavaSE 8\n), per nREPL's\n\njavadoc-info\n logic (accurate as of 29 Dec 2014)\n,\nyou can arrange your project to include the \nroot\n path of the local API doc\n(i.e., where the \nindex.html\n is located) to be included on your classpath\n(i.e., where the doc HTML files can be located by\n\nclojure.java.io/resource\n). For example, for Leiningen, with the local API\npath being \n/usr/share/doc/java/api/\n, put the following line in\n\nproject.clj\n:\n\n\n:dev {:resource-paths [\n/usr/share/doc/java/api/\n]}\n\n\n\n\nor\n the following line in \n$HOME/.lein/profiles.clj\n:\n\n\n:user {:resource-paths [\n/usr/share/doc/java/api/\n]}\n\n\n\n\nMore details can be found \nhere\n.\n\n\nFilter out namespaces in certain namespace-related commands\n\n\nYou can hide all nREPL middleware details from \ncider-browse-ns*\n and \ncider-apropos*\n\ncommands by customizing the variable \ncider-filter-regexps\n. It should be a list of\nregexps matching the pattern of namespaces you want to filter out.\n\n\nIts default value is \n'(\"^cider.nrepl\" \"^refactor-nrepl\" \"^clojure.tools.nrepl\")\n,\nthe most commonly used middleware collections/packages.\n\n\nAn important thing to note is that this list of regexps is passed on to the middleware\nwithout any pre-processing. So, the regexps have to be in Clojure format (with twice the number of backslashes)\nand not Emacs Lisp. For example, to achieve the above effect, you could also set \ncider-filter-regexps\n to \n'(\".*nrepl\")\n.\n\n\nTo customize \ncider-filter-regexps\n, you could use the Emacs customize UI,\nwith \nM-x\n \ncustomize-variable\n \nRET\n \ncider-filter-regexps\n.\n\n\nOr by including a similar snippet along with the other CIDER configuration.\n\n\n(setq cider-filter-regexps '(\n.*nrepl\n))\n\n\n\n\nTruncate long lines in special buffers\n\n\nBy default contents of CIDER's special buffers such as \n*cider-test-report*\n\nor \n*cider-doc*\n are line truncated. You can set\n\ncider-special-mode-truncate-lines\n to \nnil\n to make those buffers use word\nwrapping instead of line truncating.\n\n\nThis variable should be set before loading CIDER\n (which means before\n\nrequire\n-ing it or autoloading it).\n\n\n(setq cider-special-mode-truncate-lines nil)\n\n\n\n\nSyntax highlighting\n\n\nDynamic syntax highlighting\n\n\nCIDER can syntax highlight symbols that are known to be defined. By default,\nthis is done on symbols from the \nclojure.core\n namespace, as well as macros\nfrom any namespace. If you'd like CIDER to also colorize usages of functions\nand variables from any namespace, do:\n\n\n(setq cider-font-lock-dynamically '(macro core function var))\n\n\n\n\nHere's how code looks without dynamic syntax highlighting.\n\n\n\n\nAnd here's how to the code looks when it's turned on.\n\n\n\n\nSyntax highlighting for reader conditionals\n\n\nBy default CIDER will apply font-locking to unused reader conditional\nexpressions depending on the buffer CIDER connection type.\n\n\n\n\nYou can disable this behavior by adjusting \ncider-font-lock-reader-conditionals\n:\n\n\n(setq cider-font-lock-reader-conditionals nil)\n\n\n\n\nCustomizing CIDER faces\n\n\nCIDER defines a few custom faces that you might want to adjust (although normally your color theme\nshould take care of them):\n\n\n\n\ncider-deprecated-face\n - used for syntax highlighting deprecated vars\n\n\ncider-instrumented-face\n - used for syntax highlighting instrumented for debugging vars\n\n\ncider-traced-face\n - used for syntax highlighting traced vars\n\n\ncider-reader-conditional-face\n - used for syntax highlighting inactive reader conditional branches\n\n\n\n\nConfiguring eldoc\n\n\n\n\nEnable \neldoc\n in Clojure buffers:\n\n\n\n\n(add-hook 'cider-mode-hook #'eldoc-mode)\n\n\n\n\n\n\n\n\nCIDER also would show the eldoc for the symbol at point. So in \n(map inc ...)\n\nwhen the cursor is over \ninc\n its eldoc would be displayed. You can turn off this\nbehaviour by:\n\n\n\n\n(setq cider-eldoc-display-for-symbol-at-point nil)\n\n\n\n\n\n\nCIDER respects the value of \neldoc-echo-area-use-multiline-p\n when\ndisplaying documentation in the minibuffer. You can customize this variable to change\nits behaviour.\n\n\n\n\n\n\n\n\n\n\neldoc-echo-area-use-multiline-p\n\n\nBehaviour\n\n\n\n\n\n\n\n\n\n\nt\n\n\nNever attempt to truncate messages. Complete symbol name and function arglist or variable documentation will be displayed even if echo area must be resized to fit.\n\n\n\n\n\n\nnil\n\n\nMessages are always truncated to fit in a single line of display in the echo area.\n\n\n\n\n\n\ntruncate-sym-name-if-fit\n or anything non-nil\n\n\nSymbol name may be truncated if it will enable the function arglist or documentation string to fit on a single line. Otherwise, behavior is just like \nt\n case.\n\n\n\n\n\n\n\n\n\n\nCIDER will try to add expected function arguments based on the current context\n(for example for the \ndatomic.api/q\n function where it will show the expected\ninputs of the query at point), if the variable \ncider-eldoc-display-context-dependent-info\n\nis non-nil:\n\n\n\n\n(setq cider-eldoc-display-context-dependent-info t)\n\n\n\n\nOverlays\n\n\nWhen you evaluate code in Clojure files, the result is displayed in the buffer\nitself, in an overlay right after the evaluated code.  If you want this overlay\nto be font-locked (syntax-highlighted) like Clojure code, set the following\nvariable.\n\n\n(setq cider-overlays-use-font-lock t)\n\n\n\n\nYou can disable overlays entirely (and display results in the echo-area at the\nbottom) with the \ncider-use-overlays\n variable.\n\n\n(setq cider-use-overlays nil)\n\n\n\n\nSpecifying indentation\n\n\nIt is common for macros to require special indentation mechanisms. This is most\ncommon in macros that start with \ndo\n, \ndef\n, or \nwith-\n.  CIDER has some\nheuristics to detect these macros, but it also lets you explicitly specify how\na macro should be indented.\n\n\nHere's a simple example of how someone would specify the indent spec for a macro\nthey've written (using an example in core):\n\n\n(defmacro with-in-str\n  \n[DOCSTRING]\n\n  {:style/indent 1}\n  [s \n body]\n  ...cut for brevity...)\n\n\n\n\nAnd here's a more complex one:\n\n\n(defmacro letfn\n  \n[DOCSTRING]\n\n  {:style/indent [1 [[:defn]] :form]}\n  [fnspecs \n body]\n  ...cut for brevity...)\n\n\n\n\nDon't worry if this looks intimidating. For most macros the indent spec should\nbe either just a number, or one of the keywords \n:defn\n or \n:form\n. A full\ndescription of the spec is provided in the\n\nindent spec section of the manual\n.\n\n\nIf you \ndon't\n want to use this feature, you can disable it by setting\n\ncider-dynamic-indentation\n to \nnil\n in your Emacs init file.\n\n\n(setq cider-dynamic-indentation nil)\n\n\n\n\nMinibuffer completion\n\n\nOut-of-the box CIDER uses the standard \ncompleting-read\n Emacs mechanism. While\nit's not fancy it certainly gets the job done (just press \nTAB\n). There\nare, however, ways to improve upon the standard completion if you wish to.\n\n\nicomplete\n\n\nicomplete\n is bundled with Emacs and enhances the default minibuffer completion:\n\n\n(require 'icomplete)\n\n\n\n\nYou can learn more about \nicomplete\n\n\nhere\n.\n\n\nido\n\n\nido\n is also bundled with Emacs and offers more features than \nicomplete\n.\nIf you are using \nido\n, be sure to use both \nido-everywhere\n\nand \nido-completing-read+\n.\nYou might also want to install \nido-flex\n.\n\n\nivy (recommended)\n\n\nIf you're fine with installing a third-party package for enhanced minibuffer\ncompletion you can't go wrong with the modern and versatile\n\nivy\n.\n\n\nPretty-printing\n\n\nYou can configure the function used by CIDER for pretty-printing evaluation\nresults and other data using the \ncider-pprint-fn\n option.\n\n\nThis can be one of three values (defaults to \npprint\n):\n\n\n\n\n\n\npprint\n to use the built-in \nclojure.pprint/pprint\n.\n\n\n\n\n\n\nfipp\n to use the\n  \nFast Idiomatic Pretty-Printer\n. This is\n  approximately 5-10x faster than \nclojure.core/pprint\n.\n\n\n\n\n\n\npuget\n to use \nPuget\n, which builds on\n  Fipp to provide a\n  \ncanonical serialization\n\n  of data, at a slight performance cost.\n\n\n\n\n\n\nAlternatively, \ncider-pprint-fn\n can be set to the namespace-qualified name of a\nClojure function that takes a single argument and will pretty-print the value of\nsaid argument to \n*out*\n.\n\n\n(setq cider-pprint-fn \nuser/my-pprint\n)\n\n\n\n\nThis function must be resolvable by CIDER at the time it is called (i.e. its\ncontaining namespace must have already been required).\n\n\nCIDER will bind \n*print-length*\n, \n*print-level*\n, \n*print-meta*\n, and\n\nclojure.pprint/*print-right-margin*\n when calling the pretty-printing\nfunction - the function you provide is expected to respect these options.", 
            "title": "Configuration"
        }, 
        {
            "location": "/configuration/#basic-configuration", 
            "text": "", 
            "title": "Basic configuration"
        }, 
        {
            "location": "/configuration/#auto-enabling-cider-mode-in-clojure-mode-buffers", 
            "text": "By default CIDER will enable  cider-mode  in all  clojure-mode  buffers when the\nfirst CIDER connection is established. It will also add a  clojure-mode  hook to\nenable it on newly created  clojure-mode  buffers. The configuration snippet\nbellow allows you to override this (somewhat non-standard) behavior.  ;; Suppress auto-enabling of `cider-mode` in `clojure-mode` buffers, when starting CIDER\n(setq cider-auto-mode nil)", 
            "title": "Auto-enabling cider-mode in clojure-mode buffers"
        }, 
        {
            "location": "/configuration/#prompt-for-confirmation-of-the-symbol-at-point", 
            "text": "By default, interactive commands that require a symbol (e.g.  cider-doc ) will\nprompt for the symbol, with the prompt defaulting to the symbol at point. You\ncan set  cider-prompt-for-symbol  to  nil  to instead try the command with the\nsymbol at point first, and only prompt if that fails (this used to be the\ndefault behavior in older CIDER releases).  (setq cider-prompt-for-symbol nil)", 
            "title": "Prompt for confirmation of the symbol at point"
        }, 
        {
            "location": "/configuration/#log-communication-with-the-nrepl-server", 
            "text": "(setq nrepl-log-messages t)  Basically, this will result in the creation of buffers like  *nrepl-messages\nconn-name* . The communication log is invaluable for debugging CIDER issues, so\nyou're generally advised to enable logging when you need to debug something\nnREPL related.", 
            "title": "Log communication with the nREPL server"
        }, 
        {
            "location": "/configuration/#hide-special-nrepl-buffers", 
            "text": "You can hide the  *nrepl-connection*  and  *nrepl-server*  buffers\nfrom appearing in some buffer switching commands like switch-to-buffer ( C-x b ) like this:  (setq nrepl-hide-special-buffers t)  When using  switch-to-buffer , pressing  SPC  after the command will\nmake the hidden buffers visible. They'll always be visible in list-buffers  ( C-x C-b ).", 
            "title": "Hide special nREPL buffers"
        }, 
        {
            "location": "/configuration/#prefer-local-resources-over-remote-ones", 
            "text": "To prefer local resources to remote (tramp) ones when both are available:  (setq cider-prefer-local-resources t)", 
            "title": "Prefer local resources over remote ones"
        }, 
        {
            "location": "/configuration/#auto-save-clojure-buffers-on-load", 
            "text": "Normally CIDER would prompt you to save a modified Clojure buffer on  C-c C-k  ( cider-load-buffer ).\nYou can change this behaviour by adjusting  cider-save-file-on-load :  ;; Don't prompt and don't save\n(setq cider-save-file-on-load nil)\n;; Just save without prompting\n(setq cider-save-file-on-load t)", 
            "title": "Auto-save Clojure buffers on load"
        }, 
        {
            "location": "/configuration/#changing-the-result-prefix-for-interactive-evaluation", 
            "text": "Change the result prefix for interactive evaluation (by default it's  = ):  (setq cider-eval-result-prefix  ;; =   )  To remove the prefix altogether just set it to an empty string( \"\" ).", 
            "title": "Changing the result prefix for interactive evaluation"
        }, 
        {
            "location": "/configuration/#use-a-local-copy-of-the-jdk-api-documentation", 
            "text": "If you are targeting the JVM and prefer a local copy of the JDK API\ndocumentation over Oracle's official copy (e.g., for JavaSE 8 ), per nREPL's javadoc-info  logic (accurate as of 29 Dec 2014) ,\nyou can arrange your project to include the  root  path of the local API doc\n(i.e., where the  index.html  is located) to be included on your classpath\n(i.e., where the doc HTML files can be located by clojure.java.io/resource ). For example, for Leiningen, with the local API\npath being  /usr/share/doc/java/api/ , put the following line in project.clj :  :dev {:resource-paths [ /usr/share/doc/java/api/ ]}  or  the following line in  $HOME/.lein/profiles.clj :  :user {:resource-paths [ /usr/share/doc/java/api/ ]}  More details can be found  here .", 
            "title": "Use a local copy of the JDK API documentation"
        }, 
        {
            "location": "/configuration/#filter-out-namespaces-in-certain-namespace-related-commands", 
            "text": "You can hide all nREPL middleware details from  cider-browse-ns*  and  cider-apropos* \ncommands by customizing the variable  cider-filter-regexps . It should be a list of\nregexps matching the pattern of namespaces you want to filter out.  Its default value is  '(\"^cider.nrepl\" \"^refactor-nrepl\" \"^clojure.tools.nrepl\") ,\nthe most commonly used middleware collections/packages.  An important thing to note is that this list of regexps is passed on to the middleware\nwithout any pre-processing. So, the regexps have to be in Clojure format (with twice the number of backslashes)\nand not Emacs Lisp. For example, to achieve the above effect, you could also set  cider-filter-regexps  to  '(\".*nrepl\") .  To customize  cider-filter-regexps , you could use the Emacs customize UI,\nwith  M-x   customize-variable   RET   cider-filter-regexps .  Or by including a similar snippet along with the other CIDER configuration.  (setq cider-filter-regexps '( .*nrepl ))", 
            "title": "Filter out namespaces in certain namespace-related commands"
        }, 
        {
            "location": "/configuration/#truncate-long-lines-in-special-buffers", 
            "text": "By default contents of CIDER's special buffers such as  *cider-test-report* \nor  *cider-doc*  are line truncated. You can set cider-special-mode-truncate-lines  to  nil  to make those buffers use word\nwrapping instead of line truncating.  This variable should be set before loading CIDER  (which means before require -ing it or autoloading it).  (setq cider-special-mode-truncate-lines nil)", 
            "title": "Truncate long lines in special buffers"
        }, 
        {
            "location": "/configuration/#syntax-highlighting", 
            "text": "", 
            "title": "Syntax highlighting"
        }, 
        {
            "location": "/configuration/#dynamic-syntax-highlighting", 
            "text": "CIDER can syntax highlight symbols that are known to be defined. By default,\nthis is done on symbols from the  clojure.core  namespace, as well as macros\nfrom any namespace. If you'd like CIDER to also colorize usages of functions\nand variables from any namespace, do:  (setq cider-font-lock-dynamically '(macro core function var))  Here's how code looks without dynamic syntax highlighting.   And here's how to the code looks when it's turned on.", 
            "title": "Dynamic syntax highlighting"
        }, 
        {
            "location": "/configuration/#syntax-highlighting-for-reader-conditionals", 
            "text": "By default CIDER will apply font-locking to unused reader conditional\nexpressions depending on the buffer CIDER connection type.   You can disable this behavior by adjusting  cider-font-lock-reader-conditionals :  (setq cider-font-lock-reader-conditionals nil)", 
            "title": "Syntax highlighting for reader conditionals"
        }, 
        {
            "location": "/configuration/#customizing-cider-faces", 
            "text": "CIDER defines a few custom faces that you might want to adjust (although normally your color theme\nshould take care of them):   cider-deprecated-face  - used for syntax highlighting deprecated vars  cider-instrumented-face  - used for syntax highlighting instrumented for debugging vars  cider-traced-face  - used for syntax highlighting traced vars  cider-reader-conditional-face  - used for syntax highlighting inactive reader conditional branches", 
            "title": "Customizing CIDER faces"
        }, 
        {
            "location": "/configuration/#configuring-eldoc", 
            "text": "Enable  eldoc  in Clojure buffers:   (add-hook 'cider-mode-hook #'eldoc-mode)    CIDER also would show the eldoc for the symbol at point. So in  (map inc ...) \nwhen the cursor is over  inc  its eldoc would be displayed. You can turn off this\nbehaviour by:   (setq cider-eldoc-display-for-symbol-at-point nil)   CIDER respects the value of  eldoc-echo-area-use-multiline-p  when\ndisplaying documentation in the minibuffer. You can customize this variable to change\nits behaviour.      eldoc-echo-area-use-multiline-p  Behaviour      t  Never attempt to truncate messages. Complete symbol name and function arglist or variable documentation will be displayed even if echo area must be resized to fit.    nil  Messages are always truncated to fit in a single line of display in the echo area.    truncate-sym-name-if-fit  or anything non-nil  Symbol name may be truncated if it will enable the function arglist or documentation string to fit on a single line. Otherwise, behavior is just like  t  case.      CIDER will try to add expected function arguments based on the current context\n(for example for the  datomic.api/q  function where it will show the expected\ninputs of the query at point), if the variable  cider-eldoc-display-context-dependent-info \nis non-nil:   (setq cider-eldoc-display-context-dependent-info t)", 
            "title": "Configuring eldoc"
        }, 
        {
            "location": "/configuration/#overlays", 
            "text": "When you evaluate code in Clojure files, the result is displayed in the buffer\nitself, in an overlay right after the evaluated code.  If you want this overlay\nto be font-locked (syntax-highlighted) like Clojure code, set the following\nvariable.  (setq cider-overlays-use-font-lock t)  You can disable overlays entirely (and display results in the echo-area at the\nbottom) with the  cider-use-overlays  variable.  (setq cider-use-overlays nil)", 
            "title": "Overlays"
        }, 
        {
            "location": "/configuration/#specifying-indentation", 
            "text": "It is common for macros to require special indentation mechanisms. This is most\ncommon in macros that start with  do ,  def , or  with- .  CIDER has some\nheuristics to detect these macros, but it also lets you explicitly specify how\na macro should be indented.  Here's a simple example of how someone would specify the indent spec for a macro\nthey've written (using an example in core):  (defmacro with-in-str\n   [DOCSTRING] \n  {:style/indent 1}\n  [s   body]\n  ...cut for brevity...)  And here's a more complex one:  (defmacro letfn\n   [DOCSTRING] \n  {:style/indent [1 [[:defn]] :form]}\n  [fnspecs   body]\n  ...cut for brevity...)  Don't worry if this looks intimidating. For most macros the indent spec should\nbe either just a number, or one of the keywords  :defn  or  :form . A full\ndescription of the spec is provided in the indent spec section of the manual .  If you  don't  want to use this feature, you can disable it by setting cider-dynamic-indentation  to  nil  in your Emacs init file.  (setq cider-dynamic-indentation nil)", 
            "title": "Specifying indentation"
        }, 
        {
            "location": "/configuration/#minibuffer-completion", 
            "text": "Out-of-the box CIDER uses the standard  completing-read  Emacs mechanism. While\nit's not fancy it certainly gets the job done (just press  TAB ). There\nare, however, ways to improve upon the standard completion if you wish to.", 
            "title": "Minibuffer completion"
        }, 
        {
            "location": "/configuration/#icomplete", 
            "text": "icomplete  is bundled with Emacs and enhances the default minibuffer completion:  (require 'icomplete)  You can learn more about  icomplete  here .", 
            "title": "icomplete"
        }, 
        {
            "location": "/configuration/#ido", 
            "text": "ido  is also bundled with Emacs and offers more features than  icomplete .\nIf you are using  ido , be sure to use both  ido-everywhere \nand  ido-completing-read+ .\nYou might also want to install  ido-flex .", 
            "title": "ido"
        }, 
        {
            "location": "/configuration/#ivy-recommended", 
            "text": "If you're fine with installing a third-party package for enhanced minibuffer\ncompletion you can't go wrong with the modern and versatile ivy .", 
            "title": "ivy (recommended)"
        }, 
        {
            "location": "/configuration/#pretty-printing", 
            "text": "You can configure the function used by CIDER for pretty-printing evaluation\nresults and other data using the  cider-pprint-fn  option.  This can be one of three values (defaults to  pprint ):    pprint  to use the built-in  clojure.pprint/pprint .    fipp  to use the\n   Fast Idiomatic Pretty-Printer . This is\n  approximately 5-10x faster than  clojure.core/pprint .    puget  to use  Puget , which builds on\n  Fipp to provide a\n   canonical serialization \n  of data, at a slight performance cost.    Alternatively,  cider-pprint-fn  can be set to the namespace-qualified name of a\nClojure function that takes a single argument and will pretty-print the value of\nsaid argument to  *out* .  (setq cider-pprint-fn  user/my-pprint )  This function must be resolvable by CIDER at the time it is called (i.e. its\ncontaining namespace must have already been required).  CIDER will bind  *print-length* ,  *print-level* ,  *print-meta* , and clojure.pprint/*print-right-margin*  when calling the pretty-printing\nfunction - the function you provide is expected to respect these options.", 
            "title": "Pretty-printing"
        }, 
        {
            "location": "/indent_spec/", 
            "text": "Overview\n\n\nAn indent spec can be used to specify intricate indentation rules for the more\ncomplex macros (or functions). It is provided as a value in the var metadata,\nunder the \n:style/indent\n key.\n\n\n(defmacro with-in-str\n  \n[DOCSTRING]\n\n  {:style/indent 1}\n  [s \n body]\n  ...cut for brevity...)\n\n\n\n\nIt can take one of 3 forms:\n\n\n\n\nAbsent, meaning \n\u201cindent like a regular function call\u201d\n.\n\n\nAn integer or a keyword \nx\n, which is shorthand for the list \n[x]\n.\n\n\nA list, meaning that this function/macro takes a number of special arguments,\n  and then all other arguments are non-special.\n\n\nThe first element\n describes how the arguments are indented relative to the sexp. It can be:\n\n\nAn integer \nn\n, which indicates this function/macro takes \nn\n special\n  arguments (see below for the meaning of this).\n\n\nThe keyword \n:form\n, meaning \n\u201cevery arg indents like a function form\u201d\n.\n\n\nThe keyword \n:defn\n, which means \n\u201cevery arg not on the first line is non-special\u201d\n.\n\n\n\n\n\n\nEach following element\n is an indent spec on its own, and it details the\n    internal structure of the argument on the same position as this element. So,\n    when that argument is a form, this element specifies how to indent that form\n    internally (if it's not a form the spec is irrelevant).\n\n\nIf the function/macro has more arguments than the list has elements, the last\n    element of the list applies to all remaining arguments.\n\n\n\n\n\n\nExamples\n\n\nHere we go into several examples using some well-known macros and forms from\n\nclojure.core\n. Obviously these are already known by \nclojure-mode\n, so you\ndon't need to specify them. They are just examples to guide you when writing\nindent specs for your own macros, or for macros from third party libs.\n\n\nOne very simple example is the \ndo\n form. All of its arguments get the same\nindentation, and none of them are special. So its indent spec is simply \n[0]\n,\nor \n0\n for short.\n\n\n(do\n  (something)\n  (quick))\n\n(do (whatever)\n    (you)\n    (want))\n\n\n\n\nSticking to simplicity, the \nwhen-let*\n macro has one special argument (the\nbinding vector) and there's no out-of-the-ordinary internal structure\ninvolved. So the indent spec is just \n1\n (which is shorthand for \n[1]\n).\n\n\n\n\nLet's see something more sophisticated. If the \ndefrecord\n indent spec used by\n\nclojure-mode\n is \n[2 :form :form [1]]\n. This is saying:\n\n\n\n\ndefrecord\n has 2 special arguments (the name and the arglist).\n\n\nThe first two arguments have no special internal structure.\n\n\nAll remaining arguments have an internal indent spec of \n[1]\n (which means\n  only the arglist is indented specially and the rest is the body).\n\n\n\n\n(defrecord Thing [a]\n  FileNameMap\n  (getContentTypeFor [_ file-name]\n    (str a \n-\n file-name))\n  Object\n  (toString [_]\n    \nMy very own thing!!\n))\n\n\n\n\nFor something even more complicated: \nletfn\n is \n[1 [[:defn]] :form]\n. This means\n\n\n\n\nletfn\n has one special argument (the bindings list).\n\n\nThe first arg has an indent spec of \n[[:defn]]\n, which means all forms\n  \ninside\n the first arg have an indent spec of \n[:defn]\n.\n\n\nThe second argument, and all other arguments, are regular forms.\n\n\n\n\n(letfn [(twice [x]\n          (* x 2))\n        (six-times [y]\n          (* (twice y) 3))]\n  (six-times 15))\n\n\n\n\nSpecial Arguments\n\n\nMany macros have a number of \u201cspecial\u201d arguments, followed by an arbitrary\nnumber of \u201cnon-special\u201d arguments (sometimes called the body). The \u201cnon-special\u201d\narguments have a small indentation (usually 2 spaces). The special arguments\nare usually on the same line as the macro name, but, when necessary, they are\nplaced on a separate line with additional indentation.\n\n\nFor instance, \ndefrecord\n has two special arguments, and here's how it might be indented:\n\n\n(defrecord TheNameOfTheRecord\n    [a pretty long argument list]\n  SomeType\n  (assoc [_ x]\n    (.assoc pretty x 10)))\n\n\n\n\nHere's another way one could do it:\n\n\n(defrecord TheNameOfTheRecord\n           [a pretty long argument list]\n  SomeType\n  (assoc [_ x]\n    (.assoc pretty x 10)))\n\n\n\n\nThe point of the indent spec is \nnot\n to specify how many spaces to use.\n\n\nThe point is just to say \u201ca defrecord has \n2\n special arguments\u201d, and then let\nthe editor and the user come to an agreement on how many spaces they like to use\nfor special and non-special arguments.\n\n\nInternal indentation\n\n\nThe issue goes a bit deeper. Note the last argument in that \ndefrecord\n. A\nregular function form would be internally indented as:\n\n\n(assoc [_ x]\n       (.assoc pretty x 10))\n\n\n\n\nBut this is not a regular function call, it's a definition. So we want to\nspecify that this form internally has 1 special argument (the arglist vector),\nso that it will be indented like this:\n\n\n(assoc [_ x]\n  (.assoc pretty x 10))\n\n\n\n\nThe indent spec does this as well. It lets you specify that, for each argument\nbeyond the 2nd, if it is a form, it should be internally indented as having 1\nspecial argument.", 
            "title": "Indentation Specification"
        }, 
        {
            "location": "/indent_spec/#overview", 
            "text": "An indent spec can be used to specify intricate indentation rules for the more\ncomplex macros (or functions). It is provided as a value in the var metadata,\nunder the  :style/indent  key.  (defmacro with-in-str\n   [DOCSTRING] \n  {:style/indent 1}\n  [s   body]\n  ...cut for brevity...)  It can take one of 3 forms:   Absent, meaning  \u201cindent like a regular function call\u201d .  An integer or a keyword  x , which is shorthand for the list  [x] .  A list, meaning that this function/macro takes a number of special arguments,\n  and then all other arguments are non-special.  The first element  describes how the arguments are indented relative to the sexp. It can be:  An integer  n , which indicates this function/macro takes  n  special\n  arguments (see below for the meaning of this).  The keyword  :form , meaning  \u201cevery arg indents like a function form\u201d .  The keyword  :defn , which means  \u201cevery arg not on the first line is non-special\u201d .    Each following element  is an indent spec on its own, and it details the\n    internal structure of the argument on the same position as this element. So,\n    when that argument is a form, this element specifies how to indent that form\n    internally (if it's not a form the spec is irrelevant).  If the function/macro has more arguments than the list has elements, the last\n    element of the list applies to all remaining arguments.", 
            "title": "Overview"
        }, 
        {
            "location": "/indent_spec/#examples", 
            "text": "Here we go into several examples using some well-known macros and forms from clojure.core . Obviously these are already known by  clojure-mode , so you\ndon't need to specify them. They are just examples to guide you when writing\nindent specs for your own macros, or for macros from third party libs.  One very simple example is the  do  form. All of its arguments get the same\nindentation, and none of them are special. So its indent spec is simply  [0] ,\nor  0  for short.  (do\n  (something)\n  (quick))\n\n(do (whatever)\n    (you)\n    (want))  Sticking to simplicity, the  when-let*  macro has one special argument (the\nbinding vector) and there's no out-of-the-ordinary internal structure\ninvolved. So the indent spec is just  1  (which is shorthand for  [1] ).   Let's see something more sophisticated. If the  defrecord  indent spec used by clojure-mode  is  [2 :form :form [1]] . This is saying:   defrecord  has 2 special arguments (the name and the arglist).  The first two arguments have no special internal structure.  All remaining arguments have an internal indent spec of  [1]  (which means\n  only the arglist is indented specially and the rest is the body).   (defrecord Thing [a]\n  FileNameMap\n  (getContentTypeFor [_ file-name]\n    (str a  -  file-name))\n  Object\n  (toString [_]\n     My very own thing!! ))  For something even more complicated:  letfn  is  [1 [[:defn]] :form] . This means   letfn  has one special argument (the bindings list).  The first arg has an indent spec of  [[:defn]] , which means all forms\n   inside  the first arg have an indent spec of  [:defn] .  The second argument, and all other arguments, are regular forms.   (letfn [(twice [x]\n          (* x 2))\n        (six-times [y]\n          (* (twice y) 3))]\n  (six-times 15))", 
            "title": "Examples"
        }, 
        {
            "location": "/indent_spec/#special-arguments", 
            "text": "Many macros have a number of \u201cspecial\u201d arguments, followed by an arbitrary\nnumber of \u201cnon-special\u201d arguments (sometimes called the body). The \u201cnon-special\u201d\narguments have a small indentation (usually 2 spaces). The special arguments\nare usually on the same line as the macro name, but, when necessary, they are\nplaced on a separate line with additional indentation.  For instance,  defrecord  has two special arguments, and here's how it might be indented:  (defrecord TheNameOfTheRecord\n    [a pretty long argument list]\n  SomeType\n  (assoc [_ x]\n    (.assoc pretty x 10)))  Here's another way one could do it:  (defrecord TheNameOfTheRecord\n           [a pretty long argument list]\n  SomeType\n  (assoc [_ x]\n    (.assoc pretty x 10)))  The point of the indent spec is  not  to specify how many spaces to use.  The point is just to say \u201ca defrecord has  2  special arguments\u201d, and then let\nthe editor and the user come to an agreement on how many spaces they like to use\nfor special and non-special arguments.", 
            "title": "Special Arguments"
        }, 
        {
            "location": "/indent_spec/#internal-indentation", 
            "text": "The issue goes a bit deeper. Note the last argument in that  defrecord . A\nregular function form would be internally indented as:  (assoc [_ x]\n       (.assoc pretty x 10))  But this is not a regular function call, it's a definition. So we want to\nspecify that this form internally has 1 special argument (the arglist vector),\nso that it will be indented like this:  (assoc [_ x]\n  (.assoc pretty x 10))  The indent spec does this as well. It lets you specify that, for each argument\nbeyond the 2nd, if it is a form, it should be internally indented as having 1\nspecial argument.", 
            "title": "Internal indentation"
        }, 
        {
            "location": "/additional_packages/", 
            "text": "There are many additional Emacs packages that can enhance your Clojure programming\nexperience. The majority of the minor modes listed here should be enabled for both\n\ncider-repl-mode\n and \nclojure-mode\n for optimal effects.\n\n\nclj-refactor\n\n\nclr-refactor\n builds on top\nof clojure-mode and CIDER and adds a ton of extra functionality (e.g. the\nability to thread/unthread expression, find and replace usages, introduce let\nbindings, extract function and so on).\n\n\nA full list of features is available\n\nhere\n.\n\n\nWe hope to incorporate some of its features into clojure-mode and CIDER themselves\ndown the road.\n\n\nMake sure that the version of \nclj-refactor\n you've installed is compatible with\nyour CIDER version.\n\n\nclojure-cheatsheet\n\n\nclojure-cheatsheet\n in an\nEmacs rendition of the web-based\n\nofficial Clojure Cheatsheet\n, that's easily\nsearchable via Helm.\n\n\nhelm-cider\n\n\nhelm-cider\n provides Helm\ninterface for certain CIDER commands (e.g. \ncider-apropos\n).\n\n\ncider-hydra\n\n\ncider-hydra\n provides a nice way\nto navigate groups of related CIDER commands.\n\n\nYou can think of it as a fancier \nwhich-key\n.\n\n\nsquiggly-clojure\n\n\nsquiggly-clojure\n is a\nFlycheck checker for Clojure, using tools like\n\neastwood\n,\n\ncore.typed\n and\n\nkibit\n.\n\n\ninf-clojure\n\n\nThis package provides basic interaction with a Clojure subprocess (REPL). It's\nbased on ideas from the popular inferior-lisp package.\n\n\ninf-clojure\n has two components -\na nice Clojure REPL with auto-completion and a minor mode\n(\ninf-clojure-minor-mode\n), which extends clojure-mode with commands to evaluate\nforms directly in the REPL.\n\n\nIt's basically a simple alternative of CIDER, which provides a subset of CIDER's\nfunctionality.\n\n\nsubword-mode\n\n\nEnabling \nCamelCase\n support for editing commands(like\n\nforward-word\n, \nbackward-word\n, etc) in the REPL is quite useful since\nwe often have to deal with Java class and method names. The built-in\nEmacs minor mode \nsubword-mode\n provides such functionality:\n\n\n(add-hook 'cider-repl-mode-hook #'subword-mode)\n\n\n\n\nParedit\n\n\nThe use of \nparedit\n\nwhen editing Clojure (or any other Lisp) code is highly\nrecommended.  You're probably using it already in your \nclojure-mode\n\nbuffers (if you're not you probably should). You might also want to\nenable \nparedit\n in the REPL buffer as well:\n\n\n(add-hook 'cider-repl-mode-hook #'paredit-mode)\n\n\n\n\nSmartparens\n\n\nsmartparens\n is an excellent alternative\n  to paredit. Many Clojure hackers have adopted it recently and you might want\n  to give it a try as well. To enable \nsmartparens\n in the REPL buffer use the\n  following code:\n\n\n(add-hook 'cider-repl-mode-hook #'smartparens-strict-mode)\n\n\n\n\nrainbow-delimiters\n\n\nRainbowDelimiters\n is a minor\nmode which highlights parentheses, brackets, and braces according to their\ndepth. Each successive level is highlighted in a different color. This makes it\neasy to spot matching delimiters, orient yourself in the code, and tell which\nstatements are at a given depth. Assuming you've already installed\nRainbowDelimiters you can enable it in the REPL like this:\n\n\n(add-hook 'cider-repl-mode-hook #'rainbow-delimiters-mode)\n\n\n\n\nauto-complete\n\n\nauto-complete\n is a popular Emacs\ninteractive auto-completion\nframework. \nac-cider\n provides a\ncompletion source for auto-complete-mode, including, where CIDER provides it,\npop-up documentation for completed symbols.\n\n\neval-sexp-fu\n\n\neval-sexp-fu\n provides some visual\nfeedback when evaluating expressions. \ncider-eval-sexp-fu\n provides\nCIDER integration for \neval-sexp-fu\n.\n\n\n(require 'cider-eval-sexp-fu)", 
            "title": "Additional Packages"
        }, 
        {
            "location": "/additional_packages/#clj-refactor", 
            "text": "clr-refactor  builds on top\nof clojure-mode and CIDER and adds a ton of extra functionality (e.g. the\nability to thread/unthread expression, find and replace usages, introduce let\nbindings, extract function and so on).  A full list of features is available here .  We hope to incorporate some of its features into clojure-mode and CIDER themselves\ndown the road.  Make sure that the version of  clj-refactor  you've installed is compatible with\nyour CIDER version.", 
            "title": "clj-refactor"
        }, 
        {
            "location": "/additional_packages/#clojure-cheatsheet", 
            "text": "clojure-cheatsheet  in an\nEmacs rendition of the web-based official Clojure Cheatsheet , that's easily\nsearchable via Helm.", 
            "title": "clojure-cheatsheet"
        }, 
        {
            "location": "/additional_packages/#helm-cider", 
            "text": "helm-cider  provides Helm\ninterface for certain CIDER commands (e.g.  cider-apropos ).", 
            "title": "helm-cider"
        }, 
        {
            "location": "/additional_packages/#cider-hydra", 
            "text": "cider-hydra  provides a nice way\nto navigate groups of related CIDER commands.  You can think of it as a fancier  which-key .", 
            "title": "cider-hydra"
        }, 
        {
            "location": "/additional_packages/#squiggly-clojure", 
            "text": "squiggly-clojure  is a\nFlycheck checker for Clojure, using tools like eastwood , core.typed  and kibit .", 
            "title": "squiggly-clojure"
        }, 
        {
            "location": "/additional_packages/#inf-clojure", 
            "text": "This package provides basic interaction with a Clojure subprocess (REPL). It's\nbased on ideas from the popular inferior-lisp package.  inf-clojure  has two components -\na nice Clojure REPL with auto-completion and a minor mode\n( inf-clojure-minor-mode ), which extends clojure-mode with commands to evaluate\nforms directly in the REPL.  It's basically a simple alternative of CIDER, which provides a subset of CIDER's\nfunctionality.", 
            "title": "inf-clojure"
        }, 
        {
            "location": "/additional_packages/#subword-mode", 
            "text": "Enabling  CamelCase  support for editing commands(like forward-word ,  backward-word , etc) in the REPL is quite useful since\nwe often have to deal with Java class and method names. The built-in\nEmacs minor mode  subword-mode  provides such functionality:  (add-hook 'cider-repl-mode-hook #'subword-mode)", 
            "title": "subword-mode"
        }, 
        {
            "location": "/additional_packages/#paredit", 
            "text": "The use of  paredit \nwhen editing Clojure (or any other Lisp) code is highly\nrecommended.  You're probably using it already in your  clojure-mode \nbuffers (if you're not you probably should). You might also want to\nenable  paredit  in the REPL buffer as well:  (add-hook 'cider-repl-mode-hook #'paredit-mode)", 
            "title": "Paredit"
        }, 
        {
            "location": "/additional_packages/#smartparens", 
            "text": "smartparens  is an excellent alternative\n  to paredit. Many Clojure hackers have adopted it recently and you might want\n  to give it a try as well. To enable  smartparens  in the REPL buffer use the\n  following code:  (add-hook 'cider-repl-mode-hook #'smartparens-strict-mode)", 
            "title": "Smartparens"
        }, 
        {
            "location": "/additional_packages/#rainbow-delimiters", 
            "text": "RainbowDelimiters  is a minor\nmode which highlights parentheses, brackets, and braces according to their\ndepth. Each successive level is highlighted in a different color. This makes it\neasy to spot matching delimiters, orient yourself in the code, and tell which\nstatements are at a given depth. Assuming you've already installed\nRainbowDelimiters you can enable it in the REPL like this:  (add-hook 'cider-repl-mode-hook #'rainbow-delimiters-mode)", 
            "title": "rainbow-delimiters"
        }, 
        {
            "location": "/additional_packages/#auto-complete", 
            "text": "auto-complete  is a popular Emacs\ninteractive auto-completion\nframework.  ac-cider  provides a\ncompletion source for auto-complete-mode, including, where CIDER provides it,\npop-up documentation for completed symbols.", 
            "title": "auto-complete"
        }, 
        {
            "location": "/additional_packages/#eval-sexp-fu", 
            "text": "eval-sexp-fu  provides some visual\nfeedback when evaluating expressions.  cider-eval-sexp-fu  provides\nCIDER integration for  eval-sexp-fu .  (require 'cider-eval-sexp-fu)", 
            "title": "eval-sexp-fu"
        }, 
        {
            "location": "/caveats/", 
            "text": "ClojureScript limitations\n\n\nCurrently, the following features are not supported for ClojureScript\ndevelopment:\n\n\n\n\nGrimoire lookup\n\n\nReloading\n\n\nRunning tests\n\n\nTracing\n\n\nDebugging (check out \nthis ticket\n dedicated to porting the debugger to ClojureScript)\n\n\nEnlighten\n\n\n\n\nThere is currently no support for both Clojure and ClojureScript evaluation in\nthe same nREPL session. If Piggieback is active, code evaluation and all\nfeatures will assume ClojureScript.\n\n\nVar Metadata\n\n\nCurrently var metadata about the location of the var's definition within the\nClojureScript source code (file, line \n column) is set only when evaluating the\nentire source buffer (\nC-c C-k\n). All other interactive code evaluation\ncommands (e.g. \nC-c C-e\n) don't set this metadata and you won't be able\nto use commands like \nfind-var\n on such vars.  This is a limitation of nREPL and\npiggieback, that's beyond CIDER. You can find some discussions on the subject\n\nhere\n and\n\nhere\n.\n\n\nMicrosoft Windows\n\n\nLine separators\n\n\nOn Microsoft Windows the JVM default line separator string is \n\\r\\n\n\nwhich can appear in Emacs as \n^M\n characters at the end of lines\nprinted out by the JVM. One option is to set the\n\nbuffer-display-table\n to not show these characters as detailed\n\nhere\n\n(changing \nslime-repl-mode-hook\n to\n\ncider-repl-mode-hook\n). Alternatively, setting the system property\n\nline.separator\n to \n\\n\n at JVM startup will stop the carriage return\nfrom being printed and will fix output in all cider buffers. To do so\nadd \n\"-Dline.separator=\\\"\\n\\\"\"\n to \n:jvm-opts\n in\n\n~/.lein/profiles.clj\n.\n\n\nDefinition lookup in jar files\n\n\nIn order for source lookup commands to work with \n.jar\n files you'll need to\ninstall either \n7zip\n or \npkunzip\n and add its\ninstallation folder to Emacs's \nexec-path\n. Here's an example:\n\n\n(add-to-list 'exec-path \nC:/Program Files/7-Zip\n)\n\n\n\n\npowershell.el\n\n\nThe powershell inferior shell mode truncates CIDER's REPL output when\nloaded. As a workaround remove\n\n\n(require 'powershell)\n\n\n\n\nfrom your Emacs config.\n\n\nClojureCLR Support\n\n\nCIDER currently doesn't support ClojureCLR. The reasons for this are the following:\n\n\n\n\nnREPL itself runs only on the JVM (because it leverages Java APIs\ninternally). There's an\n\nnREPL port for ClojureCLR\n, but\nit's not actively maintained and it doesn't behave like the Clojure nREPL.\n\n\ncider-nrepl\n uses a lot of Java code internally itself.\n\n\n\n\nThose issues are not insurmountable, but are beyond the scope of our current roadmap.\nIf someone would like to tackle them, we'd be happy to provide assistance.\n\n\nInjecting dependencies and Leiningen pedantic: abort mode\n\n\nBecause injection currently creates an override of \ntools.nrepl\n dependency that\nLeingingen also pulls in starting up the REPL will fail if \n:pedantic? :abort\n\nis set. Either remove the \n:pedantic? :abort\n setting or switch off injecting\nthe dependencies with setting \ncider-inject-dependencies-at-jack-in\n to \nnil\n and\nprovide the dependencies by editing your \n~/.lein/profiles.clj\n as described in\nthe \nstandalone REPL\n section.", 
            "title": "Caveats"
        }, 
        {
            "location": "/caveats/#clojurescript-limitations", 
            "text": "Currently, the following features are not supported for ClojureScript\ndevelopment:   Grimoire lookup  Reloading  Running tests  Tracing  Debugging (check out  this ticket  dedicated to porting the debugger to ClojureScript)  Enlighten   There is currently no support for both Clojure and ClojureScript evaluation in\nthe same nREPL session. If Piggieback is active, code evaluation and all\nfeatures will assume ClojureScript.", 
            "title": "ClojureScript limitations"
        }, 
        {
            "location": "/caveats/#var-metadata", 
            "text": "Currently var metadata about the location of the var's definition within the\nClojureScript source code (file, line   column) is set only when evaluating the\nentire source buffer ( C-c C-k ). All other interactive code evaluation\ncommands (e.g.  C-c C-e ) don't set this metadata and you won't be able\nto use commands like  find-var  on such vars.  This is a limitation of nREPL and\npiggieback, that's beyond CIDER. You can find some discussions on the subject here  and here .", 
            "title": "Var Metadata"
        }, 
        {
            "location": "/caveats/#microsoft-windows", 
            "text": "", 
            "title": "Microsoft Windows"
        }, 
        {
            "location": "/caveats/#line-separators", 
            "text": "On Microsoft Windows the JVM default line separator string is  \\r\\n \nwhich can appear in Emacs as  ^M  characters at the end of lines\nprinted out by the JVM. One option is to set the buffer-display-table  to not show these characters as detailed here \n(changing  slime-repl-mode-hook  to cider-repl-mode-hook ). Alternatively, setting the system property line.separator  to  \\n  at JVM startup will stop the carriage return\nfrom being printed and will fix output in all cider buffers. To do so\nadd  \"-Dline.separator=\\\"\\n\\\"\"  to  :jvm-opts  in ~/.lein/profiles.clj .", 
            "title": "Line separators"
        }, 
        {
            "location": "/caveats/#definition-lookup-in-jar-files", 
            "text": "In order for source lookup commands to work with  .jar  files you'll need to\ninstall either  7zip  or  pkunzip  and add its\ninstallation folder to Emacs's  exec-path . Here's an example:  (add-to-list 'exec-path  C:/Program Files/7-Zip )", 
            "title": "Definition lookup in jar files"
        }, 
        {
            "location": "/caveats/#powershellel", 
            "text": "The powershell inferior shell mode truncates CIDER's REPL output when\nloaded. As a workaround remove  (require 'powershell)  from your Emacs config.", 
            "title": "powershell.el"
        }, 
        {
            "location": "/caveats/#clojureclr-support", 
            "text": "CIDER currently doesn't support ClojureCLR. The reasons for this are the following:   nREPL itself runs only on the JVM (because it leverages Java APIs\ninternally). There's an nREPL port for ClojureCLR , but\nit's not actively maintained and it doesn't behave like the Clojure nREPL.  cider-nrepl  uses a lot of Java code internally itself.   Those issues are not insurmountable, but are beyond the scope of our current roadmap.\nIf someone would like to tackle them, we'd be happy to provide assistance.", 
            "title": "ClojureCLR Support"
        }, 
        {
            "location": "/caveats/#injecting-dependencies-and-leiningen-pedantic-abort-mode", 
            "text": "Because injection currently creates an override of  tools.nrepl  dependency that\nLeingingen also pulls in starting up the REPL will fail if  :pedantic? :abort \nis set. Either remove the  :pedantic? :abort  setting or switch off injecting\nthe dependencies with setting  cider-inject-dependencies-at-jack-in  to  nil  and\nprovide the dependencies by editing your  ~/.lein/profiles.clj  as described in\nthe  standalone REPL  section.", 
            "title": "Injecting dependencies and Leiningen pedantic: abort mode"
        }, 
        {
            "location": "/troubleshooting/", 
            "text": "In case you run into issues here are a few tips that can help you diagnose the\nproblem.\n\n\nGenerally, it's not a bad idea to configure Emacs to spit the backtrace on error\n(instead of just logging the error in the \n*Messages*\n buffer). You can toggle\nthis behavior by using \nM-x\n \ntoggle-debug-on-error\n.\n\n\nAnother good idea is to check the exchange of requests and responses between\nCIDER and the nREPL server. You can find them in the \n*nrepl-messages*\n buffer,\nprovided you've enabled nREPL message logging.\n\n\nDebugging CIDER commands\n\n\nEmacs features a super powerful built-in\n\nEmacs Lisp debugger\n\nand using it is the best way to diagnose problems of any kind.\n\n\nHere's a \ngreat crash course\n on\nusing the debugger.\n\n\nTo debug some command you need to do the following:\n\n\n\n\nFigure out the name of the command you want to debug (e.g. by using \nC-h k\n\nto see which command is associated with some keybinding)\n\n\nFind the source of the command (e.g. by using \nM-x\n \nfind-function\n\n  \nRET\n \nfunction-name\n)\n\n\nPress \nC-u C-M-x\n while in the body of the function\n\n\nRun the command again\n\n\n\n\nAt this point you'll be dropped in the debugger and you can step forward until\nyou find the problem.\n\n\nREPL not starting\n\n\nMake sure that your CIDER version matches your \ncider-nrepl\n version. Check\nthe contents of the \n*Messages*\n buffer for CIDER-related errors. You should\nalso check the nREPL messages passed between CIDER and nREPL in\n\n*nrepl-messages*\n. If you don't see anything useful there it's time to bring\nout the big guns.\n\n\nDebugging the REPL init\n\n\nTo debug CIDER's REPL initialization it's a good idea to hook into one of its\nentry points. Add a breakpoint to \ncider-make-repl\n (\nC-u C-M-x\n, while\nin its body). Next time you start CIDER you'll be dropped in the debugger and\nyou can step forward until you find the problem.\n\n\nMissing \n*nrepl-messages*\n buffer\n\n\nnREPL message logging is not enabled by default.  Set \nnrepl-log-messages\n to\n\nt\n to activate it. Alternatively you can use \nM-x\n \nnrepl-toggle-message-logging\n\nto enable/disable logging temporary within your current Emacs session.\n\n\ncider-debug\n complains that it \u201cfailed to instrument ...\u201d\n\n\nIn the REPL buffer, issue the following.\n\n\nyour.namespace\n (ns cider.nrepl.middleware.util.instrument)\ncider.nrepl.middleware.util.instrument\n (def verbose-debug true)\n\n\n\nThis will cause CIDER to print extensive information to the REPL buffer when you\ntry to debug an expression (e.g., with \nC-u\nC-M-x\n). \nFile an issue\n\nand copy this information.\n\n\nDebugging freezes \n lock-ups\n\n\nSometimes a CIDER command might hang for a while (e.g. due to a bug or a\nconfiguration issue). Such problems are super annoying, but are relatively easy\nto debug. Here are a few steps you can take in such situations:\n\n\n\n\nDo \nM-x\n \ntoggle-debug-on-quit\n\n\nReproduce the problem\n\n\nHit \nC-g\n around 10 seconds into the hang\n\n\n\n\nThis will bring up a backtrace with the entire function stack, including\nfunction arguments. So you should be able to figure out what's going on (or at\nleast what's being required).\n\n\nWarning saying you have to use nREPL 0.2.12+\n\n\nCIDER currently requires at least nREPL 0.2.12 to work properly (there were some\nnasty bugs in older version and no support for tracking where some var was\ndefined in the source code). Leiningen users can add this to their\n\nprofiles.clj\n to force the proper dependency:\n\n\n{:repl {:dependencies [[org.clojure/tools.nrepl \n0.2.12\n]]}}\n\n\n\n\nMake sure you add the newer nREPL dependency to the \n:dependencies\n key instead\nof \n:plugins\n (where \ncider-nrepl\n Lein plugin resides). That's a pretty common\nmistake.\n\n\nGenerally you're advised to use the newest nREPL with CIDER, as bugs get fixed\nin pretty much every release.\n\n\nNote, that running \ncider-jack-in\n from outside the scope of a project will\nresult in the \nolder (0.2.6) nREPL dependency being used\n (at least on Leiningen\n2.5.1). This is likely a Leiningen bug.\n\n\nMissing clojure-... function after CIDER update\n\n\nMost likely you've updated CIDER, without updating \nclojure-mode\n as well.\n\n\nCIDER depends on \nclojure-mode\n and you should always update them together, as\nthe latest CIDER version might depend on functionality present only in the latest\n\nclojure-mode\n version.\n\n\nI upgraded CIDER using \npackage.el\n and it broke\n\n\nThe built-in package manager isn't perfect and sometimes it messes up.  If you\njust updated and encountered an error you should try the following before\nopening an issue: Go into the \n.emacs.d/elpa\n directory, delete any folders\nrelated to CIDER, restart Emacs and then re-install the missing packages.  Note\nthat the order here matters.\n\n\nI upgraded CIDER using \npackage.el\n and nothing changed\n\n\nEmacs doesn't load the new files, it only installs them on disk.  To see the\neffect of changes you have to restart Emacs.\n\n\nCIDER complains of the \ncider-nrepl\n version\n\n\nThis is a warning displayed on the REPL buffer when it starts, and usually looks like this:\n\n\n\n\nWARNING:\n CIDER's version (0.12.0) does not match cider-nrepl's version (...). Things will break!\n\n\n\n\nwhere \n...\n might be an actual version, like \n0.10.0\n, or it might be \nnot installed\n or \nnil\n.\nThe solution to this depends on what you see and on what you're doing.\n\n\nYou see a number like \nX.X.X\n, and you're starting the REPL with \ncider-connect\n\n\nYour project specifies the wrong version for the cider-nrepl middleware. See the\n\ninstructions\n\non the Installation section.\n\n\nYou see \nnot installed\n or \nnil\n, and you're starting the REPL with \ncider-connect\n\n\nTo use \ncider-connect\n you need to add the cider-nrepl middleware to your project. See the\n\ninstructions\n\non the Installation section.\n\n\nYou see \nnot installed\n or \nnil\n, and you're starting the REPL with \ncider-jack-in\n\n\n\n\nDo \nC-h v cider-inject-dependencies-at-jack-in\n, and check that this variable is non-nil.\n\n\nMake sure your project depends on at least Clojure \n1.7.0\n.\n\n\nIf you use leiningen, make sure your \nlein --version\n is at least \n2.6.1\n.\n\n\nIf you use boot and you've changed \ncider-boot-parameters\n, that's probably the cause.\n\n\n\n\nIf the above doesn't work, you can try specifying the cider-nrepl middleware\nmanually, as per the\n\ninstructions\n\non the Installation section.\n\n\nYou see a number like \nX.X.X\n, and you're starting the REPL with \ncider-jack-in\n\n\nThis means you're manually adding the cider-nrepl middleware in your project,\nbut you shouldn't do that because \ncider-jack-in\n already does that for\nyou. Look into the following files, and ensure you've removed all references to\n\ncider-nrepl\n and \ntools.nrepl\n: \nproject.clj\n, \nbuild.boot\n,\n\n~/.lein/profiles.clj\n and \n~/.boot/profile.boot\n.", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/troubleshooting/#debugging-cider-commands", 
            "text": "Emacs features a super powerful built-in Emacs Lisp debugger \nand using it is the best way to diagnose problems of any kind.  Here's a  great crash course  on\nusing the debugger.  To debug some command you need to do the following:   Figure out the name of the command you want to debug (e.g. by using  C-h k \nto see which command is associated with some keybinding)  Find the source of the command (e.g. by using  M-x   find-function \n   RET   function-name )  Press  C-u C-M-x  while in the body of the function  Run the command again   At this point you'll be dropped in the debugger and you can step forward until\nyou find the problem.", 
            "title": "Debugging CIDER commands"
        }, 
        {
            "location": "/troubleshooting/#repl-not-starting", 
            "text": "Make sure that your CIDER version matches your  cider-nrepl  version. Check\nthe contents of the  *Messages*  buffer for CIDER-related errors. You should\nalso check the nREPL messages passed between CIDER and nREPL in *nrepl-messages* . If you don't see anything useful there it's time to bring\nout the big guns.", 
            "title": "REPL not starting"
        }, 
        {
            "location": "/troubleshooting/#debugging-the-repl-init", 
            "text": "To debug CIDER's REPL initialization it's a good idea to hook into one of its\nentry points. Add a breakpoint to  cider-make-repl  ( C-u C-M-x , while\nin its body). Next time you start CIDER you'll be dropped in the debugger and\nyou can step forward until you find the problem.", 
            "title": "Debugging the REPL init"
        }, 
        {
            "location": "/troubleshooting/#missing-nrepl-messages-buffer", 
            "text": "nREPL message logging is not enabled by default.  Set  nrepl-log-messages  to t  to activate it. Alternatively you can use  M-x   nrepl-toggle-message-logging \nto enable/disable logging temporary within your current Emacs session.", 
            "title": "Missing *nrepl-messages* buffer"
        }, 
        {
            "location": "/troubleshooting/#cider-debug-complains-that-it-failed-to-instrument", 
            "text": "In the REPL buffer, issue the following.  your.namespace  (ns cider.nrepl.middleware.util.instrument)\ncider.nrepl.middleware.util.instrument  (def verbose-debug true)  This will cause CIDER to print extensive information to the REPL buffer when you\ntry to debug an expression (e.g., with  C-u\nC-M-x ).  File an issue \nand copy this information.", 
            "title": "cider-debug complains that it \u201cfailed to instrument ...\u201d"
        }, 
        {
            "location": "/troubleshooting/#debugging-freezes-lock-ups", 
            "text": "Sometimes a CIDER command might hang for a while (e.g. due to a bug or a\nconfiguration issue). Such problems are super annoying, but are relatively easy\nto debug. Here are a few steps you can take in such situations:   Do  M-x   toggle-debug-on-quit  Reproduce the problem  Hit  C-g  around 10 seconds into the hang   This will bring up a backtrace with the entire function stack, including\nfunction arguments. So you should be able to figure out what's going on (or at\nleast what's being required).", 
            "title": "Debugging freezes &amp; lock-ups"
        }, 
        {
            "location": "/troubleshooting/#warning-saying-you-have-to-use-nrepl-0212", 
            "text": "CIDER currently requires at least nREPL 0.2.12 to work properly (there were some\nnasty bugs in older version and no support for tracking where some var was\ndefined in the source code). Leiningen users can add this to their profiles.clj  to force the proper dependency:  {:repl {:dependencies [[org.clojure/tools.nrepl  0.2.12 ]]}}  Make sure you add the newer nREPL dependency to the  :dependencies  key instead\nof  :plugins  (where  cider-nrepl  Lein plugin resides). That's a pretty common\nmistake.  Generally you're advised to use the newest nREPL with CIDER, as bugs get fixed\nin pretty much every release.  Note, that running  cider-jack-in  from outside the scope of a project will\nresult in the  older (0.2.6) nREPL dependency being used  (at least on Leiningen\n2.5.1). This is likely a Leiningen bug.", 
            "title": "Warning saying you have to use nREPL 0.2.12+"
        }, 
        {
            "location": "/troubleshooting/#missing-clojure-function-after-cider-update", 
            "text": "Most likely you've updated CIDER, without updating  clojure-mode  as well.  CIDER depends on  clojure-mode  and you should always update them together, as\nthe latest CIDER version might depend on functionality present only in the latest clojure-mode  version.", 
            "title": "Missing clojure-... function after CIDER update"
        }, 
        {
            "location": "/troubleshooting/#i-upgraded-cider-using-packageel-and-it-broke", 
            "text": "The built-in package manager isn't perfect and sometimes it messes up.  If you\njust updated and encountered an error you should try the following before\nopening an issue: Go into the  .emacs.d/elpa  directory, delete any folders\nrelated to CIDER, restart Emacs and then re-install the missing packages.  Note\nthat the order here matters.", 
            "title": "I upgraded CIDER using package.el and it broke"
        }, 
        {
            "location": "/troubleshooting/#i-upgraded-cider-using-packageel-and-nothing-changed", 
            "text": "Emacs doesn't load the new files, it only installs them on disk.  To see the\neffect of changes you have to restart Emacs.", 
            "title": "I upgraded CIDER using package.el and nothing changed"
        }, 
        {
            "location": "/troubleshooting/#cider-complains-of-the-cider-nrepl-version", 
            "text": "This is a warning displayed on the REPL buffer when it starts, and usually looks like this:   WARNING:  CIDER's version (0.12.0) does not match cider-nrepl's version (...). Things will break!   where  ...  might be an actual version, like  0.10.0 , or it might be  not installed  or  nil .\nThe solution to this depends on what you see and on what you're doing.", 
            "title": "CIDER complains of the cider-nrepl version"
        }, 
        {
            "location": "/troubleshooting/#you-see-a-number-like-xxx-and-youre-starting-the-repl-with-cider-connect", 
            "text": "Your project specifies the wrong version for the cider-nrepl middleware. See the instructions \non the Installation section.", 
            "title": "You see a number like X.X.X, and you're starting the REPL with cider-connect"
        }, 
        {
            "location": "/troubleshooting/#you-see-not-installed-or-nil-and-youre-starting-the-repl-with-cider-connect", 
            "text": "To use  cider-connect  you need to add the cider-nrepl middleware to your project. See the instructions \non the Installation section.", 
            "title": "You see not installed or nil, and you're starting the REPL with cider-connect"
        }, 
        {
            "location": "/troubleshooting/#you-see-not-installed-or-nil-and-youre-starting-the-repl-with-cider-jack-in", 
            "text": "Do  C-h v cider-inject-dependencies-at-jack-in , and check that this variable is non-nil.  Make sure your project depends on at least Clojure  1.7.0 .  If you use leiningen, make sure your  lein --version  is at least  2.6.1 .  If you use boot and you've changed  cider-boot-parameters , that's probably the cause.   If the above doesn't work, you can try specifying the cider-nrepl middleware\nmanually, as per the instructions \non the Installation section.", 
            "title": "You see not installed or nil, and you're starting the REPL with cider-jack-in"
        }, 
        {
            "location": "/troubleshooting/#you-see-a-number-like-xxx-and-youre-starting-the-repl-with-cider-jack-in", 
            "text": "This means you're manually adding the cider-nrepl middleware in your project,\nbut you shouldn't do that because  cider-jack-in  already does that for\nyou. Look into the following files, and ensure you've removed all references to cider-nrepl  and  tools.nrepl :  project.clj ,  build.boot , ~/.lein/profiles.clj  and  ~/.boot/profile.boot .", 
            "title": "You see a number like X.X.X, and you're starting the REPL with cider-jack-in"
        }, 
        {
            "location": "/faq/", 
            "text": "What does CIDER stand for?\n\n\nCIDER stands for \nC\nlojure \nI\nnteractive \nD\nevelopment \nE\nnvironment that \nR\nocks.\n\n\nDoes it really rock?\n\n\nYes.\n\n\nWhat are CIDER's installation prerequisites?\n\n\nCIDER officially supports Emacs 24.4+, Java 7+ and Clojure(Script) 1.7+.\nCIDER 0.10 was the final release which supported Java 6 and Clojure 1.5 and 1.6.\n\n\nWhat's the relationship between CIDER and nrepl.el?\n\n\nnrepl.el\n was renamed to CIDER in version 0.3 to avoid confusion with the nREPL\nserver itself and to better reflect the fact that CIDER is way more than an\nnREPL client for Emacs.  Additionally, the new name presents us with the\nopportunity to support alternative evaluation backends (e.g. the socket REPL\nintroduced in Clojure 1.8) down the road.\n\n\nWhat's the relationship between CIDER and monroe?\n\n\nmonroe\n is basically a fork of an old CIDER\nversion before the time we started relying on nREPL middleware.\n\n\nWhat's the relationship between CIDER and inf-clojure?\n\n\nThere's pretty much no relationship. \ninf-clojure\n provides a REPL based on the\n\ncomint\n Emacs package - you're basically running an external REPL process\ninside of Emacs (there's no network connectivity involved).  The advantage of\nthis is that you have no external dependencies what-so-ever - you just need some\ncommand to start a REPL process for you.\n\n\nIsn't IntelliJ's Cursive the best Clojure IDE?\n\n\nCursive is pretty awesome. Depending on your programming preferences (using an IDE vs\nbuilding a custom editing experience tailored to your needs) it might be a better\noption for you than CIDER.\n\n\nWhat's the deal with the CIDER release codenames?\n\n\nThe codenames are usually some of the favourite places of CIDER's head\nmaintainer (Bozhidar).\n\n\nIs using CIDER a good idea if I'm new to both Emacs and Clojure?\n\n\nThere's nothing particularly complex in CIDER itself, but getting to\ngrips with Emacs might be a bit challenging for some people.\n\n\nGenerally you can simplify the initial learning experience a lot by using some\nEmacs \"starter kit\" and picking up a good book on Emacs\n(e.g. \nMastering Emacs\n).\n\n\nPrelude\n\nand \nSpacemacs\n are some great Emacs distributions that\nyou might consider using.\n\n\nPrelude is maintained by the primary CIDER author himself, while\nSpacemacs is an excellent option for vim refugees (as it places a heavy emphasis\non vim emulation via \nevil-mode\n).\n\n\nDo stable CIDER releases follow some predefined cadence?\n\n\nNo. Stable releases are issued when the maintainers feel a new release is\nwarranted. The maintainers generally aim to deliver at least 2-3 stable releases\nper year.\n\n\nWhen is CIDER 1.0 going to be released?\n\n\nThere's no exact roadmap for the 1.0 release. Roughly speaking the idea is to\nrelease 1.0 once our ClojureScript support is as good as the Clojure support and\nwhen the most important refactoring functionality from our sibling\nproject \nclj-refactor\n lands\ninto CIDER.\n\n\nIs it true that stable CIDER releases often happen around major Clojure conferences?\n\n\nYep. We want to give people a reason to talk about CIDER at such events. :-)\n\n\nHow unstable is the MELPA build of CIDER?\n\n\nIt's pretty stable. Serious regression are introduced rather rarely and are\nusually fixed within a few hours. Using the MELPA build gives you early access to\nnew features and you're also helping the maintainers with the testing process.\n\n\nWill CIDER eventually support the Clojure 1.8 socket REPL?\n\n\nHopefully yes. Adding support for the socket REPL is definitely on our radar, but\nunfortunately it will require both significant changes to CIDER and the development\nof some alternative to essential nREPL functionality (like multiple evaluation sessions)\nfor the socket REPL.\n\n\nWill CIDER ever drop support for nREPL?\n\n\nThat's extremely unlikely. Even if we eventually add support for the new socket REPL,\nwe'll continue supporting nREPL as well.\n\n\nIs CIDER's nREPL middleware Emacs specific?\n\n\nNot at all. The functionality in \ncider-nrepl\n is pretty editor-agnostic and is\nutilized by various editor plugins. Some prominent examples would be\n\nvim-fireplace\n and Eclipse's CCW.\n\n\nHow can I see all the configuration options available in CIDER?\n\n\nM-x customize-group RET cider RET\n.\n\n\nAre there any interesting CIDER add-ons worth checking out?\n\n\nSure! See \nadditional packages\n for details.\n\n\nWhere can I get help regarding CIDER?\n\n\nSee the \nSupport\n section of the manual.\n\n\nWhat should I do if I run into some issues with CIDER?\n\n\nDon't panic! Next step - visit the \nTroubleshooting\n section of\nthe manual.\n\n\nHow can I help the project?\n\n\nThere are many ways in which you can help CIDER\n\n\n\n\nDonate funds\n\n\nWork on improving the documentation\n\n\nSolve open issues\n\n\nFile bug reports and suggestions for improvements\n\n\nPromote CIDER via blog posts or at meetups and conferences\n\n\nInvite members of the CIDER team to speak about CIDER at meetups and conferences", 
            "title": "FAQ"
        }, 
        {
            "location": "/faq/#what-does-cider-stand-for", 
            "text": "CIDER stands for  C lojure  I nteractive  D evelopment  E nvironment that  R ocks.", 
            "title": "What does CIDER stand for?"
        }, 
        {
            "location": "/faq/#does-it-really-rock", 
            "text": "Yes.", 
            "title": "Does it really rock?"
        }, 
        {
            "location": "/faq/#what-are-ciders-installation-prerequisites", 
            "text": "CIDER officially supports Emacs 24.4+, Java 7+ and Clojure(Script) 1.7+.\nCIDER 0.10 was the final release which supported Java 6 and Clojure 1.5 and 1.6.", 
            "title": "What are CIDER's installation prerequisites?"
        }, 
        {
            "location": "/faq/#whats-the-relationship-between-cider-and-nreplel", 
            "text": "nrepl.el  was renamed to CIDER in version 0.3 to avoid confusion with the nREPL\nserver itself and to better reflect the fact that CIDER is way more than an\nnREPL client for Emacs.  Additionally, the new name presents us with the\nopportunity to support alternative evaluation backends (e.g. the socket REPL\nintroduced in Clojure 1.8) down the road.", 
            "title": "What's the relationship between CIDER and nrepl.el?"
        }, 
        {
            "location": "/faq/#whats-the-relationship-between-cider-and-monroe", 
            "text": "monroe  is basically a fork of an old CIDER\nversion before the time we started relying on nREPL middleware.", 
            "title": "What's the relationship between CIDER and monroe?"
        }, 
        {
            "location": "/faq/#whats-the-relationship-between-cider-and-inf-clojure", 
            "text": "There's pretty much no relationship.  inf-clojure  provides a REPL based on the comint  Emacs package - you're basically running an external REPL process\ninside of Emacs (there's no network connectivity involved).  The advantage of\nthis is that you have no external dependencies what-so-ever - you just need some\ncommand to start a REPL process for you.", 
            "title": "What's the relationship between CIDER and inf-clojure?"
        }, 
        {
            "location": "/faq/#isnt-intellijs-cursive-the-best-clojure-ide", 
            "text": "Cursive is pretty awesome. Depending on your programming preferences (using an IDE vs\nbuilding a custom editing experience tailored to your needs) it might be a better\noption for you than CIDER.", 
            "title": "Isn't IntelliJ's Cursive the best Clojure IDE?"
        }, 
        {
            "location": "/faq/#whats-the-deal-with-the-cider-release-codenames", 
            "text": "The codenames are usually some of the favourite places of CIDER's head\nmaintainer (Bozhidar).", 
            "title": "What's the deal with the CIDER release codenames?"
        }, 
        {
            "location": "/faq/#is-using-cider-a-good-idea-if-im-new-to-both-emacs-and-clojure", 
            "text": "There's nothing particularly complex in CIDER itself, but getting to\ngrips with Emacs might be a bit challenging for some people.  Generally you can simplify the initial learning experience a lot by using some\nEmacs \"starter kit\" and picking up a good book on Emacs\n(e.g.  Mastering Emacs ).  Prelude \nand  Spacemacs  are some great Emacs distributions that\nyou might consider using.  Prelude is maintained by the primary CIDER author himself, while\nSpacemacs is an excellent option for vim refugees (as it places a heavy emphasis\non vim emulation via  evil-mode ).", 
            "title": "Is using CIDER a good idea if I'm new to both Emacs and Clojure?"
        }, 
        {
            "location": "/faq/#do-stable-cider-releases-follow-some-predefined-cadence", 
            "text": "No. Stable releases are issued when the maintainers feel a new release is\nwarranted. The maintainers generally aim to deliver at least 2-3 stable releases\nper year.", 
            "title": "Do stable CIDER releases follow some predefined cadence?"
        }, 
        {
            "location": "/faq/#when-is-cider-10-going-to-be-released", 
            "text": "There's no exact roadmap for the 1.0 release. Roughly speaking the idea is to\nrelease 1.0 once our ClojureScript support is as good as the Clojure support and\nwhen the most important refactoring functionality from our sibling\nproject  clj-refactor  lands\ninto CIDER.", 
            "title": "When is CIDER 1.0 going to be released?"
        }, 
        {
            "location": "/faq/#is-it-true-that-stable-cider-releases-often-happen-around-major-clojure-conferences", 
            "text": "Yep. We want to give people a reason to talk about CIDER at such events. :-)", 
            "title": "Is it true that stable CIDER releases often happen around major Clojure conferences?"
        }, 
        {
            "location": "/faq/#how-unstable-is-the-melpa-build-of-cider", 
            "text": "It's pretty stable. Serious regression are introduced rather rarely and are\nusually fixed within a few hours. Using the MELPA build gives you early access to\nnew features and you're also helping the maintainers with the testing process.", 
            "title": "How unstable is the MELPA build of CIDER?"
        }, 
        {
            "location": "/faq/#will-cider-eventually-support-the-clojure-18-socket-repl", 
            "text": "Hopefully yes. Adding support for the socket REPL is definitely on our radar, but\nunfortunately it will require both significant changes to CIDER and the development\nof some alternative to essential nREPL functionality (like multiple evaluation sessions)\nfor the socket REPL.", 
            "title": "Will CIDER eventually support the Clojure 1.8 socket REPL?"
        }, 
        {
            "location": "/faq/#will-cider-ever-drop-support-for-nrepl", 
            "text": "That's extremely unlikely. Even if we eventually add support for the new socket REPL,\nwe'll continue supporting nREPL as well.", 
            "title": "Will CIDER ever drop support for nREPL?"
        }, 
        {
            "location": "/faq/#is-ciders-nrepl-middleware-emacs-specific", 
            "text": "Not at all. The functionality in  cider-nrepl  is pretty editor-agnostic and is\nutilized by various editor plugins. Some prominent examples would be vim-fireplace  and Eclipse's CCW.", 
            "title": "Is CIDER's nREPL middleware Emacs specific?"
        }, 
        {
            "location": "/faq/#how-can-i-see-all-the-configuration-options-available-in-cider", 
            "text": "M-x customize-group RET cider RET .", 
            "title": "How can I see all the configuration options available in CIDER?"
        }, 
        {
            "location": "/faq/#are-there-any-interesting-cider-add-ons-worth-checking-out", 
            "text": "Sure! See  additional packages  for details.", 
            "title": "Are there any interesting CIDER add-ons worth checking out?"
        }, 
        {
            "location": "/faq/#where-can-i-get-help-regarding-cider", 
            "text": "See the  Support  section of the manual.", 
            "title": "Where can I get help regarding CIDER?"
        }, 
        {
            "location": "/faq/#what-should-i-do-if-i-run-into-some-issues-with-cider", 
            "text": "Don't panic! Next step - visit the  Troubleshooting  section of\nthe manual.", 
            "title": "What should I do if I run into some issues with CIDER?"
        }, 
        {
            "location": "/faq/#how-can-i-help-the-project", 
            "text": "There are many ways in which you can help CIDER   Donate funds  Work on improving the documentation  Solve open issues  File bug reports and suggestions for improvements  Promote CIDER via blog posts or at meetups and conferences  Invite members of the CIDER team to speak about CIDER at meetups and conferences", 
            "title": "How can I help the project?"
        }, 
        {
            "location": "/additional_resources/", 
            "text": "Quick reference\n\n\nA single-page quick reference PDF for CIDER commands is available\n\nhere\n. This PDF can be created manually by running\n\npdflatex\n on \nthe CIDER refcard LaTeX file\n.\n\n\nDemos\n\n\n\n\nDeep Dive into CIDER\n - an overview of CIDER's essential features\n\n\nEmacs \n Clojure, A Lispy Love Affair\n - an overview of all popular Emacs packages for Clojure development (including CIDER)\n\n\n\n\nPresentations\n\n\n\n\nThe Evolution of the Emacs tooling for Clojure\n -\n  presented at Clojure/conj 2014; dedicated to the origin and the architecture\n  of CIDER and related tooling\n\n\nCIDER: The Journey so Far and the Road Ahead\n -\n  presented at ClojureX 2015; dedicated to CIDER 0.9 and 0.10 and the future of\n  the project.\n\n\nA Few Pints of CIDER\n - presented at Clojure Remote 2016; dedicated\nto CIDER 0.11; features a 10-minute live demo of some cool CIDER features.\n\n\nCIDER: Inside the Brewery\n - presented at Clojure/West 2016;\ndedicated to CIDER 0.12.\n\n\n\n\nPodcasts\n\n\n\n\nCognicast's episode on CIDER", 
            "title": "Additional Resources"
        }, 
        {
            "location": "/additional_resources/#quick-reference", 
            "text": "A single-page quick reference PDF for CIDER commands is available here . This PDF can be created manually by running pdflatex  on  the CIDER refcard LaTeX file .", 
            "title": "Quick reference"
        }, 
        {
            "location": "/additional_resources/#demos", 
            "text": "Deep Dive into CIDER  - an overview of CIDER's essential features  Emacs   Clojure, A Lispy Love Affair  - an overview of all popular Emacs packages for Clojure development (including CIDER)", 
            "title": "Demos"
        }, 
        {
            "location": "/additional_resources/#presentations", 
            "text": "The Evolution of the Emacs tooling for Clojure  -\n  presented at Clojure/conj 2014; dedicated to the origin and the architecture\n  of CIDER and related tooling  CIDER: The Journey so Far and the Road Ahead  -\n  presented at ClojureX 2015; dedicated to CIDER 0.9 and 0.10 and the future of\n  the project.  A Few Pints of CIDER  - presented at Clojure Remote 2016; dedicated\nto CIDER 0.11; features a 10-minute live demo of some cool CIDER features.  CIDER: Inside the Brewery  - presented at Clojure/West 2016;\ndedicated to CIDER 0.12.", 
            "title": "Presentations"
        }, 
        {
            "location": "/additional_resources/#podcasts", 
            "text": "Cognicast's episode on CIDER", 
            "title": "Podcasts"
        }, 
        {
            "location": "/hacking_on_cider/", 
            "text": "This section explains the process of working with CIDER's codebase (e.g. to fix\na bug or implement some new feature). It outlines the recommended workflows when\nworking on the Emacs Lisp side (CIDER) and the Clojure side (\ncider-nrepl\n).\n\n\nHacking on CIDER\n\n\nObtaining the source code\n\n\nPeople typically install CIDER via \npackage.el\n. While this gives you access the\nsource code (as it's part of the package), it's always a much better idea to\nsimply clone the code from GitHub and use it. In general - avoid editing the\ncode of an installed package.\n\n\nAlternatively you can simply load CIDER in your Emacs straight from its source\nrepo:\n\n\n;; load CIDER from its source code\n(add-to-list 'load-path \n~/projects/cider\n)\n(require 'cider)\n\n\n\n\nJust keep in mind that you'll have to manually install all the packages CIDER\ndepends on in advance.\n\n\nChanging the code\n\n\nIt's perfectly fine to load CIDER from \npackage.el\n and then to start making\nexperiments by changing existing code and adding new code.\n\n\nA very good workflow is to just open the source code you've cloned and start\nevaluating the code you've altered/added with commands like \nC-M-x\n,\n\neval-buffer\n and so on.\n\n\nOnce you've evaluated the new code, you can invoke some interactive command that\nuses it internally or open a Emacs Lisp REPL and experiment with it there. You\ncan open an Emacs Lisp REPL with \nM-x ielm\n.\n\n\nYou can also quickly evaluate some Emacs Lisp code in the minibuffer with \nM-:\n.\n\n\nTesting the code\n\n\nThe code you've wrote should ideally be covered by specs. We use\nthe \nbuttercup\n library for\nCIDER's specs. If you're familiar with \nJasmine\n or \nRSpec\n you'll feel right at\nhome.\n\n\nYou can run the specs you authored/changed straight from Emacs. Consult\nthe\n\nbuttercup documentation\n for\nall the details.\n\n\nRunning the tests in batch mode\n\n\nIf you prefer running all tests outside Emacs that's also an option.\n\n\nInstall \ncask\n if you haven't\nalready, then:\n\n\n$ cd /path/to/cider\n$ cask\n\n\n\n\nRun all tests with:\n\n\n$ make test\n\n\n\n\n(Note: tests may not run correctly inside Emacs' \nshell-mode\n buffers. Running\nthem in a terminal is recommended.)\n\n\nYou can also check for the presence of byte-compilation warnings in batch mode:\n\n\n$ make test-bytecomp\n\n\n\n\nRunning the tests in Travis CI\n\n\nIf you prefer to see the full Travis CI test suite run successfully, the easiest\nway to achieve that is to create your own personal account on\nhttps://travis-ci.org. View your profile details on the Travis CI site, and\ntoggle the switch to enable builds on your fork of the cider project.\n\n\nSubsequent pushes to your fork will generate a Travis CI build you can monitor\nfor success or failure.\n\n\nSimulating the Travis CI tests locally in Docker\n\n\nIf you prefer not to wait for Travis CI all the time, or if you need to debug\nsomething that fails in Travis CI but does not fail for you on your own machine,\nthen you can also run the Travis CI tests manually in Docker.\n\n\nYou will need to run some scripts to build and launch the Docker image.\n\n\nTo build:\n\n\n$ docker/build.sh\n\n\n\n\nThe build script uses a base image provided by the engineers at Travis CI.\n\n\nNote: The Travis docker image is currently more than 8GB, so be prepared with a\ngood internet connection and time to spare.\n\n\nThe resulting docker image is tagged simply \ncider-travis\n. You can run this\nimage by hand, but there is a convenience script available:\n\n\n$ docker/run.sh\n\n\n\n\nThis script launches a docker container and bind-mounts your cider project\ndirectory as \n/home/travis/cider\n such that you can instantly see any code\nchanges reflected inside the docker environment.\n\n\nFor instance, first you can run tests on Emacs 25.3:\n\n\n(emacs-25.3-travis) ~/cider$ make test\n\n\n\n\nAnd then switch to Emacs 26.1 and test again:\n\n\n(emacs-25.3-travis) ~/cider$ evm use Emacs-26-pretest-travis\n(emacs-26-pretest-travis) ~/cider$ cask install\n(emacs-26-pretest-travis) ~/cider$ make test\n\n\n\n\nYou can test byte compilation too\n\n\n(emacs-26-pretest-travis) ~/cider$ make test-bytecomp\n\n\n\n\nWhen you are done working in docker, just \nexit\n the bash prompt, and the docker\ncontainer will also exit. Note that \ndocker/run.sh\n runs the container with\n\n--rm\n, meaning any changes to the docker container are discarded when the\ncontainer exits.\n\n\nSo for example, by default, the docker image pre-installs only the most recent\nreleases of Emacs 25, Emacs 26, and a recent snapshot of the Emacs git\nrepository. The \nevm\n tool is available should you need to install some other\nspecific build. However additional versions of Emacs will be discarded when\nyou exit the docker container.\n\n\nHacking on cider-nrepl\n\n\nObtaining the code\n\n\nJust clone it from GitHub.\n\n\nChanging the code\n\n\nJust do \ncider-jack-in\n within the \ncider-nrepl\n project and start hacking as\nyou would on any other Clojure project.  The only thing to keep in mind is that\nyou'll have to restart CIDER when you add new middleware.\n\n\nThe jacked-in project's definitions will take precedence over the once you have\nfrom a binary \ncider-nrepl\n installation. This means it's pretty easy to get\nimmediate feedback for the changes you've made.\n\n\nTesting the code\n\n\nThe code you've wrote should ideally be covered by test. We use the\n\nclojure.test\n library for \ncider-nrepl\n's tests.\n\n\nYou can run the tests you authored/changed straight from Emacs. Consult the\n\nCIDER documentation\n for all the details.\n\n\nRunning the tests in batch mode\n\n\nYou can also run the tests in an external shell. Running \nlein test\n won't run\npretty much anything, though. (perhaps we should change this?) To run the\nClojure and ClojureScript tests you should specify some profile like this:\n\n\n$ lein with-profile +1.8,+test-clj test\n\n$ lein with-profile +1.8,+test-cljs test\n\n\n\n\n\nThis will run all Clojure and ClojureScript tests against version 1.8 of both\nlanguages.", 
            "title": "Hacking on CIDER"
        }, 
        {
            "location": "/hacking_on_cider/#hacking-on-cider", 
            "text": "", 
            "title": "Hacking on CIDER"
        }, 
        {
            "location": "/hacking_on_cider/#obtaining-the-source-code", 
            "text": "People typically install CIDER via  package.el . While this gives you access the\nsource code (as it's part of the package), it's always a much better idea to\nsimply clone the code from GitHub and use it. In general - avoid editing the\ncode of an installed package.  Alternatively you can simply load CIDER in your Emacs straight from its source\nrepo:  ;; load CIDER from its source code\n(add-to-list 'load-path  ~/projects/cider )\n(require 'cider)  Just keep in mind that you'll have to manually install all the packages CIDER\ndepends on in advance.", 
            "title": "Obtaining the source code"
        }, 
        {
            "location": "/hacking_on_cider/#changing-the-code", 
            "text": "It's perfectly fine to load CIDER from  package.el  and then to start making\nexperiments by changing existing code and adding new code.  A very good workflow is to just open the source code you've cloned and start\nevaluating the code you've altered/added with commands like  C-M-x , eval-buffer  and so on.  Once you've evaluated the new code, you can invoke some interactive command that\nuses it internally or open a Emacs Lisp REPL and experiment with it there. You\ncan open an Emacs Lisp REPL with  M-x ielm .  You can also quickly evaluate some Emacs Lisp code in the minibuffer with  M-: .", 
            "title": "Changing the code"
        }, 
        {
            "location": "/hacking_on_cider/#testing-the-code", 
            "text": "The code you've wrote should ideally be covered by specs. We use\nthe  buttercup  library for\nCIDER's specs. If you're familiar with  Jasmine  or  RSpec  you'll feel right at\nhome.  You can run the specs you authored/changed straight from Emacs. Consult\nthe buttercup documentation  for\nall the details.", 
            "title": "Testing the code"
        }, 
        {
            "location": "/hacking_on_cider/#running-the-tests-in-batch-mode", 
            "text": "If you prefer running all tests outside Emacs that's also an option.  Install  cask  if you haven't\nalready, then:  $ cd /path/to/cider\n$ cask  Run all tests with:  $ make test  (Note: tests may not run correctly inside Emacs'  shell-mode  buffers. Running\nthem in a terminal is recommended.)  You can also check for the presence of byte-compilation warnings in batch mode:  $ make test-bytecomp", 
            "title": "Running the tests in batch mode"
        }, 
        {
            "location": "/hacking_on_cider/#running-the-tests-in-travis-ci", 
            "text": "If you prefer to see the full Travis CI test suite run successfully, the easiest\nway to achieve that is to create your own personal account on\nhttps://travis-ci.org. View your profile details on the Travis CI site, and\ntoggle the switch to enable builds on your fork of the cider project.  Subsequent pushes to your fork will generate a Travis CI build you can monitor\nfor success or failure.", 
            "title": "Running the tests in Travis CI"
        }, 
        {
            "location": "/hacking_on_cider/#simulating-the-travis-ci-tests-locally-in-docker", 
            "text": "If you prefer not to wait for Travis CI all the time, or if you need to debug\nsomething that fails in Travis CI but does not fail for you on your own machine,\nthen you can also run the Travis CI tests manually in Docker.  You will need to run some scripts to build and launch the Docker image.  To build:  $ docker/build.sh  The build script uses a base image provided by the engineers at Travis CI.  Note: The Travis docker image is currently more than 8GB, so be prepared with a\ngood internet connection and time to spare.  The resulting docker image is tagged simply  cider-travis . You can run this\nimage by hand, but there is a convenience script available:  $ docker/run.sh  This script launches a docker container and bind-mounts your cider project\ndirectory as  /home/travis/cider  such that you can instantly see any code\nchanges reflected inside the docker environment.  For instance, first you can run tests on Emacs 25.3:  (emacs-25.3-travis) ~/cider$ make test  And then switch to Emacs 26.1 and test again:  (emacs-25.3-travis) ~/cider$ evm use Emacs-26-pretest-travis\n(emacs-26-pretest-travis) ~/cider$ cask install\n(emacs-26-pretest-travis) ~/cider$ make test  You can test byte compilation too  (emacs-26-pretest-travis) ~/cider$ make test-bytecomp  When you are done working in docker, just  exit  the bash prompt, and the docker\ncontainer will also exit. Note that  docker/run.sh  runs the container with --rm , meaning any changes to the docker container are discarded when the\ncontainer exits.  So for example, by default, the docker image pre-installs only the most recent\nreleases of Emacs 25, Emacs 26, and a recent snapshot of the Emacs git\nrepository. The  evm  tool is available should you need to install some other\nspecific build. However additional versions of Emacs will be discarded when\nyou exit the docker container.", 
            "title": "Simulating the Travis CI tests locally in Docker"
        }, 
        {
            "location": "/hacking_on_cider/#hacking-on-cider-nrepl", 
            "text": "", 
            "title": "Hacking on cider-nrepl"
        }, 
        {
            "location": "/hacking_on_cider/#obtaining-the-code", 
            "text": "Just clone it from GitHub.", 
            "title": "Obtaining the code"
        }, 
        {
            "location": "/hacking_on_cider/#changing-the-code_1", 
            "text": "Just do  cider-jack-in  within the  cider-nrepl  project and start hacking as\nyou would on any other Clojure project.  The only thing to keep in mind is that\nyou'll have to restart CIDER when you add new middleware.  The jacked-in project's definitions will take precedence over the once you have\nfrom a binary  cider-nrepl  installation. This means it's pretty easy to get\nimmediate feedback for the changes you've made.", 
            "title": "Changing the code"
        }, 
        {
            "location": "/hacking_on_cider/#testing-the-code_1", 
            "text": "The code you've wrote should ideally be covered by test. We use the clojure.test  library for  cider-nrepl 's tests.  You can run the tests you authored/changed straight from Emacs. Consult the CIDER documentation  for all the details.", 
            "title": "Testing the code"
        }, 
        {
            "location": "/hacking_on_cider/#running-the-tests-in-batch-mode_1", 
            "text": "You can also run the tests in an external shell. Running  lein test  won't run\npretty much anything, though. (perhaps we should change this?) To run the\nClojure and ClojureScript tests you should specify some profile like this:  $ lein with-profile +1.8,+test-clj test \n$ lein with-profile +1.8,+test-cljs test   This will run all Clojure and ClojureScript tests against version 1.8 of both\nlanguages.", 
            "title": "Running the tests in batch mode"
        }, 
        {
            "location": "/about/team/", 
            "text": "The Core Team\n\n\nThe direction of the project is being stewarded by the CIDER core team. This\ngroup of long-term contributors manage releases, evaluate pull-requests, and\ndoes a lot of the groundwork on major new features.\n\n\n\n\nBozhidar Batsov\n (author \n head maintainer)\n\n\nArtur Malabarba\n\n\nMichael Griffiths\n\n\nJeff Valk\n\n\nLars Andersen\n\n\n\n\nCIDER Alumni\n\n\nIn addition, we'd like to extend a special thanks the following retired CIDER\ncore team members. Lovingly known as The Alumni:\n\n\n\n\nTim King\n (original author)\n\n\nPhil Hagelberg\n\n\nHugo Duncan\n\n\nSteve Purcell", 
            "title": "Team"
        }, 
        {
            "location": "/about/team/#the-core-team", 
            "text": "The direction of the project is being stewarded by the CIDER core team. This\ngroup of long-term contributors manage releases, evaluate pull-requests, and\ndoes a lot of the groundwork on major new features.   Bozhidar Batsov  (author   head maintainer)  Artur Malabarba  Michael Griffiths  Jeff Valk  Lars Andersen", 
            "title": "The Core Team"
        }, 
        {
            "location": "/about/team/#cider-alumni", 
            "text": "In addition, we'd like to extend a special thanks the following retired CIDER\ncore team members. Lovingly known as The Alumni:   Tim King  (original author)  Phil Hagelberg  Hugo Duncan  Steve Purcell", 
            "title": "CIDER Alumni"
        }, 
        {
            "location": "/about/support/", 
            "text": "CIDER currently has several official \n unofficial support channels.\n\n\nFor questions, suggestions and support refer to one of them.  Please, don't\nuse the support channels to report issues, as this makes them harder to track.\n\n\nMailing list\n\n\nThe \nofficial mailing list\n is\nhosted at Google Groups. It's a low-traffic list, so don't be too hesitant to subscribe.\n\n\nFreenode\n\n\nWe've got an unofficial Freenode channel - \n#clojure-emacs\n. It's not actively\nmonitored by the CIDER maintainers themselves, but still you can get support\nfrom other CIDER users there.\n\n\nSlack\n\n\nWe've got an official \nClojurians Slack\n -\n\n#cider\n. This is usually be best way to get a handle on some of the maintainers\nand interact with other CIDER users. The channel is very active!\n\n\nThere's also another channel named \n#emacs\n for generic Emacs discussions.\n\n\nGitter\n\n\nMost internal discussions about the development of CIDER happen on its\n\ngitter channel\n.  You can often find\nCIDER's maintainers there and get some interesting news from the project's\nkitchen.\n\n\nStackoverflow\n\n\nWe're also encouraging users to ask CIDER-related questions on StackOverflow.\n\n\nWhen doing so you should use the\n\ncider\n tag (ideally combined\nwith the tags \nemacs\n and \nclojure\n).\n\n\nBountysource\n\n\nIf you're willing to pay for some feature to be implemented you can use\n\nBountysource\n to place a\nbounty for the work you want to be done.", 
            "title": "Support"
        }, 
        {
            "location": "/about/support/#mailing-list", 
            "text": "The  official mailing list  is\nhosted at Google Groups. It's a low-traffic list, so don't be too hesitant to subscribe.", 
            "title": "Mailing list"
        }, 
        {
            "location": "/about/support/#freenode", 
            "text": "We've got an unofficial Freenode channel -  #clojure-emacs . It's not actively\nmonitored by the CIDER maintainers themselves, but still you can get support\nfrom other CIDER users there.", 
            "title": "Freenode"
        }, 
        {
            "location": "/about/support/#slack", 
            "text": "We've got an official  Clojurians Slack  - #cider . This is usually be best way to get a handle on some of the maintainers\nand interact with other CIDER users. The channel is very active!  There's also another channel named  #emacs  for generic Emacs discussions.", 
            "title": "Slack"
        }, 
        {
            "location": "/about/support/#gitter", 
            "text": "Most internal discussions about the development of CIDER happen on its gitter channel .  You can often find\nCIDER's maintainers there and get some interesting news from the project's\nkitchen.", 
            "title": "Gitter"
        }, 
        {
            "location": "/about/support/#stackoverflow", 
            "text": "We're also encouraging users to ask CIDER-related questions on StackOverflow.  When doing so you should use the cider  tag (ideally combined\nwith the tags  emacs  and  clojure ).", 
            "title": "Stackoverflow"
        }, 
        {
            "location": "/about/support/#bountysource", 
            "text": "If you're willing to pay for some feature to be implemented you can use Bountysource  to place a\nbounty for the work you want to be done.", 
            "title": "Bountysource"
        }, 
        {
            "location": "/about/contributing/", 
            "text": "Issues\n\n\nReport issues and suggest features and improvements on the\n\nGitHub issue tracker\n. Don't ask\nquestions on the issue tracker - use the \nsupport channels\n instead.\n\n\nIf you want to file a bug, please provide all the necessary info listed in\nour issue reporting template (it's loaded automatically when you create a\nnew GitHub issue).\n\n\nIt's usually a good idea to try to reproduce (obscure) bugs in isolation. You\ncan do this by cloning CIDER's GitHub repo and running \nmake run-cider\n inside\nit.  This will bring up Emacs with only the latest version of CIDER loaded. By\nstarting fresh, with the latest code, we can ensure that the problem at hand\nisn't already fixed or caused by interactions with other packages.\n\n\nPatches\n\n\nPatches in any form are always welcome! GitHub pull requests are even better! :-)\n\n\nBefore submitting a patch or a pull request make sure all tests are\npassing and that your patch is in line with the \ncontribution\nguidelines\n.\n\n\nDocumentation\n\n\nGood documentation is just as important as good code.\n\n\nConsider improving and extending this manual.\n\n\nWorking on the Manual\n\n\nThe manual is generated from the markdown files in the\n\ndoc\n folder of CIDER's\nGitHub repo and is published to \nRead the Docs\n. The\n\nMkDocs\n tool is used to convert the markdown sources to\nHTML.\n\n\nTo make changes to the manual you simply have to change the files under\n\ndoc\n. The manual will be regenerated automatically when changes to those files\nare merged in \nmaster\n (or the latest stable branch).\n\n\nYou can install \nMkDocs\n locally and use the command \nmkdocs serve\n to see the\nresult of changes you make to the manual locally:\n\n\n$ cd path/to/cider/repo\n$ mkdocs serve\n\n\n\n\nIf you want to make changes to the manual's page structure you'll have to edit\n\nmkdocs.yml\n.\n\n\nFunding\n\n\nWhile CIDER is free software and will always be, the project would benefit immensely from some funding.\nRaising a monthly budget of a couple of thousand dollars would make it possible to pay people to work on\ncertain complex features, fund other development related stuff (e.g. hardware, conference trips) and so on.\nRaising a monthly budget of over $5000 would open the possibility of someone working full-time on the project\nwhich would speed up the pace of development significantly.\n\n\nWe welcome both individual and corporate sponsors! We also offer a wide array of funding channels to account\nfor your preferences (although currently \nOpen Collective\n is our preferred funding platform).\n\n\nIf you're working in a company that's making significant use of CIDER we'd appreciate it if you suggest to your company\nto become a CIDER sponsor.\n\n\nYou can support the development of CIDER, \nclojure-mode\n and \ninf-clojure\n via\n\nOpen Collective\n,\n\nSalt\n,\n\nPatreon\n,\n\nLiberapay\n and PayPal.\n\n\n\n\nOpen Collective\n\n\n\n\n[\nBecome a backer\n] (for individuals)\n\n\n[\nBecome a sponsor\n] (for companies)", 
            "title": "Contributing"
        }, 
        {
            "location": "/about/contributing/#issues", 
            "text": "Report issues and suggest features and improvements on the GitHub issue tracker . Don't ask\nquestions on the issue tracker - use the  support channels  instead.  If you want to file a bug, please provide all the necessary info listed in\nour issue reporting template (it's loaded automatically when you create a\nnew GitHub issue).  It's usually a good idea to try to reproduce (obscure) bugs in isolation. You\ncan do this by cloning CIDER's GitHub repo and running  make run-cider  inside\nit.  This will bring up Emacs with only the latest version of CIDER loaded. By\nstarting fresh, with the latest code, we can ensure that the problem at hand\nisn't already fixed or caused by interactions with other packages.", 
            "title": "Issues"
        }, 
        {
            "location": "/about/contributing/#patches", 
            "text": "Patches in any form are always welcome! GitHub pull requests are even better! :-)  Before submitting a patch or a pull request make sure all tests are\npassing and that your patch is in line with the  contribution\nguidelines .", 
            "title": "Patches"
        }, 
        {
            "location": "/about/contributing/#documentation", 
            "text": "Good documentation is just as important as good code.  Consider improving and extending this manual.", 
            "title": "Documentation"
        }, 
        {
            "location": "/about/contributing/#working-on-the-manual", 
            "text": "The manual is generated from the markdown files in the doc  folder of CIDER's\nGitHub repo and is published to  Read the Docs . The MkDocs  tool is used to convert the markdown sources to\nHTML.  To make changes to the manual you simply have to change the files under doc . The manual will be regenerated automatically when changes to those files\nare merged in  master  (or the latest stable branch).  You can install  MkDocs  locally and use the command  mkdocs serve  to see the\nresult of changes you make to the manual locally:  $ cd path/to/cider/repo\n$ mkdocs serve  If you want to make changes to the manual's page structure you'll have to edit mkdocs.yml .", 
            "title": "Working on the Manual"
        }, 
        {
            "location": "/about/contributing/#funding", 
            "text": "While CIDER is free software and will always be, the project would benefit immensely from some funding.\nRaising a monthly budget of a couple of thousand dollars would make it possible to pay people to work on\ncertain complex features, fund other development related stuff (e.g. hardware, conference trips) and so on.\nRaising a monthly budget of over $5000 would open the possibility of someone working full-time on the project\nwhich would speed up the pace of development significantly.  We welcome both individual and corporate sponsors! We also offer a wide array of funding channels to account\nfor your preferences (although currently  Open Collective  is our preferred funding platform).  If you're working in a company that's making significant use of CIDER we'd appreciate it if you suggest to your company\nto become a CIDER sponsor.  You can support the development of CIDER,  clojure-mode  and  inf-clojure  via Open Collective , Salt , Patreon , Liberapay  and PayPal.", 
            "title": "Funding"
        }, 
        {
            "location": "/about/contributing/#open-collective", 
            "text": "[ Become a backer ] (for individuals)  [ Become a sponsor ] (for companies)", 
            "title": "Open Collective"
        }, 
        {
            "location": "/about/release_policy/", 
            "text": "We're following \nSemVer\n (as much as one can be\nfollowing it when the major version is 0). At this point bumps of the\nminor (second) version number are considered major releases and always\ninclude new features or significant changes to existing features. API\ncompatibility between major releases is not a (big) concern (although we try\nto break the API rarely and only for a good reason).\n\n\nThe development cycle for the next major\nrelease starts immediately after the previous one has been\nshipped. Bugfix/point releases (if any) address only serious bugs and\nnever contain new features.\n\n\nThe versions of CIDER and \ncider-nrepl\n are always kept in sync. If you're\ntracking the \nmaster\n branch of CIDER, you should also be tracking the \nmaster\n\nbranch of \ncider-nrepl\n.", 
            "title": "Release Policy"
        }, 
        {
            "location": "/about/changelog/", 
            "text": "An extensive changelog is available \nhere\n.", 
            "title": "Changelog"
        }, 
        {
            "location": "/about/logo/", 
            "text": "CIDER's logo was created by \n@ndr-qef\n. You can find\nthe logo in various formats\n\nhere\n.\n\n\nThe logo is licensed under a\n\nCreative Commons Attribution-NonCommercial 4.0 International License\n.", 
            "title": "Logo"
        }, 
        {
            "location": "/about/license/", 
            "text": "Copyright (C) 2012-2016 Tim King, Phil Hagelberg, Bozhidar Batsov, Artur Malabarba and\n\ncontributors\n.\n\n\nCIDER is distributed under the GNU General Public License, version 3, the same as Emacs.\nType \nC-h C-c\n in Emacs to view it.\n\n\ncider-nrepl\n is distributed under the Eclipse Public License, the same as Clojure.", 
            "title": "License"
        }
    ]
}